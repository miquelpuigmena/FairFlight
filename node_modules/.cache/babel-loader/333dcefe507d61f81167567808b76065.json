{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits,\n    EventEmitter = require('events').EventEmitter,\n    net = require('net'),\n    tls = require('tls'),\n    crypto = require('crypto'),\n    f = require('util').format,\n    debugOptions = require('./utils').debugOptions,\n    parseHeader = require('../wireprotocol/shared').parseHeader,\n    decompress = require('../wireprotocol/compression').decompress,\n    Response = require('./commands').Response,\n    MongoNetworkError = require('../error').MongoNetworkError,\n    Logger = require('./logger'),\n    OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED,\n    MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE,\n    Buffer = require('safe-buffer').Buffer;\n\nvar _id = 0;\nvar debugFields = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'crl', 'cert', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'checkServerIdentity'];\nvar connectionAccountingSpy = undefined;\nvar connectionAccounting = false;\nvar connections = {};\n/**\n * Creates a new Connection instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.family=null] IP version for DNS lookup, passed down to Node's [`dns.lookup()` function](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback). If set to `6`, will only look for ipv6 addresses.\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\n * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @return {Connection} A cursor instance\n */\n\nvar Connection = function Connection(messageHandler, options) {\n  // Add event listener\n  EventEmitter.call(this); // Set empty if no options passed\n\n  this.options = options || {}; // Identification information\n\n  this.id = _id++; // Logger instance\n\n  this.logger = Logger('Connection', options); // No bson parser passed in\n\n  if (!options.bson) throw new Error('must pass in valid bson parser'); // Get bson parser\n\n  this.bson = options.bson; // Grouping tag used for debugging purposes\n\n  this.tag = options.tag; // Message handler\n\n  this.messageHandler = messageHandler; // Max BSON message size\n\n  this.maxBsonMessageSize = options.maxBsonMessageSize || 1024 * 1024 * 16 * 4; // Debug information\n\n  if (this.logger.isDebug()) this.logger.debug(f('creating connection %s with options [%s]', this.id, JSON.stringify(debugOptions(debugFields, options)))); // Default options\n\n  this.port = options.port || 27017;\n  this.host = options.host || 'localhost';\n  this.family = typeof options.family === 'number' ? options.family : void 0;\n  this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\n  this.noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  this.connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n  this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000; // Is the keepAliveInitialDelay > socketTimeout set it to half of socketTimeout\n\n  if (this.keepAliveInitialDelay > this.socketTimeout) {\n    this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n  } // If connection was destroyed\n\n\n  this.destroyed = false; // Check if we have a domain socket\n\n  this.domainSocket = this.host.indexOf('/') !== -1; // Serialize commands using function\n\n  this.singleBufferSerializtion = typeof options.singleBufferSerializtion === 'boolean' ? options.singleBufferSerializtion : true;\n  this.serializationFunction = this.singleBufferSerializtion ? 'toBinUnified' : 'toBin'; // SSL options\n\n  this.ca = options.ca || null;\n  this.crl = options.crl || null;\n  this.cert = options.cert || null;\n  this.key = options.key || null;\n  this.passphrase = options.passphrase || null;\n  this.ciphers = options.ciphers || null;\n  this.ecdhCurve = options.ecdhCurve || null;\n  this.ssl = typeof options.ssl === 'boolean' ? options.ssl : false;\n  this.rejectUnauthorized = typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\n  this.checkServerIdentity = typeof options.checkServerIdentity === 'boolean' || typeof options.checkServerIdentity === 'function' ? options.checkServerIdentity : true; // If ssl not enabled\n\n  if (!this.ssl) this.rejectUnauthorized = false; // Response options\n\n  this.responseOptions = {\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\n  }; // Flushing\n\n  this.flushing = false;\n  this.queue = []; // Internal state\n\n  this.connection = null;\n  this.writeStream = null; // Create hash method\n\n  var hash = crypto.createHash('sha1');\n  hash.update(f('%s:%s', this.host, this.port)); // Create a hash name\n\n  this.hashedName = hash.digest('hex'); // All operations in flight on the connection\n\n  this.workItems = [];\n};\n\ninherits(Connection, EventEmitter);\n\nConnection.prototype.setSocketTimeout = function (value) {\n  if (this.connection) {\n    this.connection.setTimeout(value);\n  }\n};\n\nConnection.prototype.resetSocketTimeout = function () {\n  if (this.connection) {\n    this.connection.setTimeout(this.socketTimeout);\n  }\n};\n\nConnection.enableConnectionAccounting = function (spy) {\n  if (spy) {\n    connectionAccountingSpy = spy;\n  }\n\n  connectionAccounting = true;\n  connections = {};\n};\n\nConnection.disableConnectionAccounting = function () {\n  connectionAccounting = false;\n  connectionAccountingSpy = undefined;\n};\n\nConnection.connections = function () {\n  return connections;\n};\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n} //\n// Connection handlers\n\n\nvar errorHandler = function errorHandler(self) {\n  return function (err) {\n    if (connectionAccounting) deleteConnection(self.id); // Debug information\n\n    if (self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] errored out with [%s]', self.id, self.host, self.port, JSON.stringify(err))); // Emit the error\n\n    if (self.listeners('error').length > 0) self.emit('error', new MongoNetworkError(err), self);\n  };\n};\n\nvar timeoutHandler = function timeoutHandler(self) {\n  return function () {\n    if (connectionAccounting) deleteConnection(self.id); // Debug information\n\n    if (self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] timed out', self.id, self.host, self.port)); // Emit timeout error\n\n    self.emit('timeout', new MongoNetworkError(f('connection %s to %s:%s timed out', self.id, self.host, self.port)), self);\n  };\n};\n\nvar closeHandler = function closeHandler(self) {\n  return function (hadError) {\n    if (connectionAccounting) deleteConnection(self.id); // Debug information\n\n    if (self.logger.isDebug()) self.logger.debug(f('connection %s with for [%s:%s] closed', self.id, self.host, self.port)); // Emit close event\n\n    if (!hadError) {\n      self.emit('close', new MongoNetworkError(f('connection %s to %s:%s closed', self.id, self.host, self.port)), self);\n    }\n  };\n}; // Handle a message once it is received\n\n\nvar emitMessageHandler = function emitMessageHandler(self, message) {\n  var msgHeader = parseHeader(message);\n\n  if (msgHeader.opCode === OP_COMPRESSED) {\n    msgHeader.fromCompressed = true;\n    var index = MESSAGE_HEADER_SIZE;\n    msgHeader.opCode = message.readInt32LE(index);\n    index += 4;\n    msgHeader.length = message.readInt32LE(index);\n    index += 4;\n    var compressorID = message[index];\n    index++;\n    decompress(compressorID, message.slice(index), function (err, decompressedMsgBody) {\n      if (err) {\n        throw err;\n      }\n\n      if (decompressedMsgBody.length !== msgHeader.length) {\n        throw new Error('Decompressing a compressed message from the server failed. The message is corrupt.');\n      }\n\n      self.messageHandler(new Response(self.bson, message, msgHeader, decompressedMsgBody, self.responseOptions), self);\n    });\n  } else {\n    self.messageHandler(new Response(self.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), self.responseOptions), self);\n  }\n};\n\nvar dataHandler = function dataHandler(self) {\n  return function (data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (self.bytesRead > 0 && self.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        var remainingBytesToRead = self.sizeOfMessage - self.bytesRead; // Check if the current chunk contains the rest of the message\n\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(self.buffer, self.bytesRead); // Adjust the number of bytes read so it point to the correct index in the buffer\n\n          self.bytesRead = self.bytesRead + data.length; // Reset state of buffer\n\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead); // Slice the overflow into a new buffer that we will then re-parse\n\n          data = data.slice(remainingBytesToRead); // Emit current complete message\n\n          try {\n            var emitBuffer = self.buffer; // Reset state of buffer\n\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n            emitMessageHandler(self, emitBuffer);\n          } catch (err) {\n            var errorObject = {\n              err: 'socketHandler',\n              trace: err,\n              bin: self.buffer,\n              parseState: {\n                sizeOfMessage: self.sizeOfMessage,\n                bytesRead: self.bytesRead,\n                stubBuffer: self.stubBuffer\n              }\n            }; // We got a parse Error fire it off then keep going\n\n            self.emit('parseError', errorObject, self);\n          }\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (self.stubBuffer != null && self.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (self.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            var newData = Buffer.alloc(self.stubBuffer.length + data.length);\n            self.stubBuffer.copy(newData, 0);\n            data.copy(newData, self.stubBuffer.length); // Reassign for parsing\n\n            data = newData; // Reset state of buffer\n\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            var newStubBuffer = Buffer.alloc(self.stubBuffer.length + data.length); // Copy existing stub buffer\n\n            self.stubBuffer.copy(newStubBuffer, 0); // Copy missing part of the data\n\n            data.copy(newStubBuffer, self.stubBuffer.length); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            // var sizeOfMessage = data.readUInt32LE(0);\n            var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24; // If we have a negative sizeOfMessage emit error and return\n\n            if (sizeOfMessage < 0 || sizeOfMessage > self.maxBsonMessageSize) {\n              errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: self.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: self.bytesRead,\n                  stubBuffer: self.stubBuffer\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              self.emit('parseError', errorObject, self);\n              return;\n            } // Ensure that the size of message is larger than 0 and less than the max allowed\n\n\n            if (sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage > data.length) {\n              self.buffer = Buffer.alloc(sizeOfMessage); // Copy all the data into the buffer\n\n              data.copy(self.buffer, 0); // Update bytes read\n\n              self.bytesRead = data.length; // Update sizeOfMessage\n\n              self.sizeOfMessage = sizeOfMessage; // Ensure stub buffer is null\n\n              self.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else if (sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage === data.length) {\n              try {\n                emitBuffer = data; // Reset state of buffer\n\n                self.buffer = null;\n                self.sizeOfMessage = 0;\n                self.bytesRead = 0;\n                self.stubBuffer = null; // Exit parsing loop\n\n                data = Buffer.alloc(0); // Emit the message\n\n                emitMessageHandler(self, emitBuffer);\n              } catch (err) {\n                self.emit('parseError', err, self);\n              }\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > self.maxBsonMessageSize) {\n              errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              self.emit('parseError', errorObject, self); // Clear out the state of the parser\n\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else {\n              emitBuffer = data.slice(0, sizeOfMessage); // Reset state of buffer\n\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null; // Copy rest of message\n\n              data = data.slice(sizeOfMessage); // Emit the message\n\n              emitMessageHandler(self, emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            self.stubBuffer = Buffer.alloc(data.length); // Copy the data to the stub buffer\n\n            data.copy(self.stubBuffer, 0); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}; // List of socket level valid ssl options\n\n\nvar legalSslSocketOptions = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'NPNProtocols', 'ALPNProtocols', 'servername', 'ecdhCurve', 'secureProtocol', 'secureContext', 'session', 'minDHSize'];\n\nfunction merge(options1, options2) {\n  // Merge in any allowed ssl options\n  for (var name in options2) {\n    if (options2[name] != null && legalSslSocketOptions.indexOf(name) !== -1) {\n      options1[name] = options2[name];\n    }\n  }\n}\n\nfunction makeSSLConnection(self, _options) {\n  var sslOptions = {\n    socket: self.connection,\n    rejectUnauthorized: self.rejectUnauthorized\n  }; // Merge in options\n\n  merge(sslOptions, self.options);\n  merge(sslOptions, _options); // Set options for ssl\n\n  if (self.ca) sslOptions.ca = self.ca;\n  if (self.crl) sslOptions.crl = self.crl;\n  if (self.cert) sslOptions.cert = self.cert;\n  if (self.key) sslOptions.key = self.key;\n  if (self.passphrase) sslOptions.passphrase = self.passphrase; // Override checkServerIdentity behavior\n\n  if (self.checkServerIdentity === false) {\n    // Skip the identiy check by retuning undefined as per node documents\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n    sslOptions.checkServerIdentity = function () {\n      return undefined;\n    };\n  } else if (typeof self.checkServerIdentity === 'function') {\n    sslOptions.checkServerIdentity = self.checkServerIdentity;\n  } // Set default sni servername to be the same as host\n\n\n  if (sslOptions.servername == null) {\n    sslOptions.servername = self.host;\n  } // Attempt SSL connection\n\n\n  var connection = tls.connect(self.port, self.host, sslOptions, function () {\n    // Error on auth or skip\n    if (connection.authorizationError && self.rejectUnauthorized) {\n      return self.emit('error', connection.authorizationError, self, {\n        ssl: true\n      });\n    } // Set socket timeout instead of connection timeout\n\n\n    connection.setTimeout(self.socketTimeout); // We are done emit connect\n\n    self.emit('connect', self);\n  }); // Set the options for the connection\n\n  connection.setKeepAlive(self.keepAlive, self.keepAliveInitialDelay);\n  connection.setTimeout(self.connectionTimeout);\n  connection.setNoDelay(self.noDelay);\n  return connection;\n}\n\nfunction makeUnsecureConnection(self, family) {\n  // Create new connection instance\n  var connection_options;\n\n  if (self.domainSocket) {\n    connection_options = {\n      path: self.host\n    };\n  } else {\n    connection_options = {\n      port: self.port,\n      host: self.host\n    };\n    connection_options.family = family;\n  }\n\n  var connection = net.createConnection(connection_options); // Set the options for the connection\n\n  connection.setKeepAlive(self.keepAlive, self.keepAliveInitialDelay);\n  connection.setTimeout(self.connectionTimeout);\n  connection.setNoDelay(self.noDelay);\n  connection.once('connect', function () {\n    // Set socket timeout instead of connection timeout\n    connection.setTimeout(self.socketTimeout); // Emit connect event\n\n    self.emit('connect', self);\n  });\n  return connection;\n}\n\nfunction doConnect(self, family, _options, _errorHandler) {\n  self.connection = self.ssl ? makeSSLConnection(self, _options) : makeUnsecureConnection(self, family); // Add handlers for events\n\n  self.connection.once('error', _errorHandler);\n  self.connection.once('timeout', timeoutHandler(self));\n  self.connection.once('close', closeHandler(self));\n  self.connection.on('data', dataHandler(self));\n}\n/**\n * Connect\n * @method\n */\n\n\nConnection.prototype.connect = function (_options) {\n  var _this = this;\n\n  _options = _options || {}; // Set the connections\n\n  if (connectionAccounting) addConnection(this.id, this); // Check if we are overriding the promoteLongs\n\n  if (typeof _options.promoteLongs === 'boolean') {\n    this.responseOptions.promoteLongs = _options.promoteLongs;\n    this.responseOptions.promoteValues = _options.promoteValues;\n    this.responseOptions.promoteBuffers = _options.promoteBuffers;\n  }\n\n  var _errorHandler = errorHandler(this);\n\n  if (this.family !== void 0) {\n    return doConnect(this, this.family, _options, _errorHandler);\n  }\n\n  return doConnect(this, 6, _options, function (err) {\n    if (_this.logger.isDebug()) {\n      _this.logger.debug(f('connection %s for [%s:%s] errored out with [%s]', _this.id, _this.host, _this.port, JSON.stringify(err)));\n    } // clean up existing event handlers\n\n\n    _this.connection.removeAllListeners('error');\n\n    _this.connection.removeAllListeners('timeout');\n\n    _this.connection.removeAllListeners('close');\n\n    _this.connection.removeAllListeners('data');\n\n    _this.connection = undefined;\n    return doConnect(_this, 4, _options, _errorHandler);\n  });\n};\n/**\n * Unref this connection\n * @method\n * @return {boolean}\n */\n\n\nConnection.prototype.unref = function () {\n  if (this.connection) this.connection.unref();else {\n    var self = this;\n    this.once('connect', function () {\n      self.connection.unref();\n    });\n  }\n};\n/**\n * Destroy connection\n * @method\n */\n\n\nConnection.prototype.destroy = function () {\n  // Set the connections\n  if (connectionAccounting) deleteConnection(this.id);\n\n  if (this.connection) {\n    // Catch posssible exception thrown by node 0.10.x\n    try {\n      this.connection.end();\n    } catch (err) {} // eslint-disable-line\n    // Destroy connection\n\n\n    this.connection.destroy();\n  }\n\n  this.destroyed = true;\n};\n/**\n * Write to connection\n * @method\n * @param {Command} command Command to write out need to implement toBin and toBinUnified\n */\n\n\nConnection.prototype.write = function (buffer) {\n  var i; // Debug Log\n\n  if (this.logger.isDebug()) {\n    if (!Array.isArray(buffer)) {\n      this.logger.debug(f('writing buffer [%s] to %s:%s', buffer.toString('hex'), this.host, this.port));\n    } else {\n      for (i = 0; i < buffer.length; i++) {\n        this.logger.debug(f('writing buffer [%s] to %s:%s', buffer[i].toString('hex'), this.host, this.port));\n      }\n    }\n  } // Double check that the connection is not destroyed\n\n\n  if (this.connection.destroyed === false) {\n    // Write out the command\n    if (!Array.isArray(buffer)) {\n      this.connection.write(buffer, 'binary');\n      return true;\n    } // Iterate over all buffers and write them in order to the socket\n\n\n    for (i = 0; i < buffer.length; i++) {\n      this.connection.write(buffer[i], 'binary');\n    }\n\n    return true;\n  } // Connection is destroyed return write failed\n\n\n  return false;\n};\n/**\n * Return id of connection as a string\n * @method\n * @return {string}\n */\n\n\nConnection.prototype.toString = function () {\n  return '' + this.id;\n};\n/**\n * Return json object of connection\n * @method\n * @return {object}\n */\n\n\nConnection.prototype.toJSON = function () {\n  return {\n    id: this.id,\n    host: this.host,\n    port: this.port\n  };\n};\n/**\n * Is the connection connected\n * @method\n * @return {boolean}\n */\n\n\nConnection.prototype.isConnected = function () {\n  if (this.destroyed) return false;\n  return !this.connection.destroyed && this.connection.writable;\n};\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n\nmodule.exports = Connection;","map":null,"metadata":{},"sourceType":"script"}