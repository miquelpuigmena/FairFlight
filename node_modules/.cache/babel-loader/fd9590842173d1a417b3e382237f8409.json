{"ast":null,"code":"'use strict';\n\nvar _possibleConstructorReturn = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _createClass = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar Long = require('mongodb-core').BSON.Long;\n\nvar MongoError = require('mongodb-core').MongoError;\n\nvar toError = require('../utils').toError;\n\nvar handleCallback = require('../utils').handleCallback;\n\nvar applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nvar applyWriteConcern = require('../utils').applyWriteConcern;\n\nvar ObjectID = require('mongodb-core').BSON.ObjectID;\n\nvar BSON = require('mongodb-core').BSON; // Error codes\n\n\nvar UNKNOWN_ERROR = 8;\nvar INVALID_BSON_ERROR = 22;\nvar WRITE_CONCERN_ERROR = 64;\nvar MULTIPLE_ERROR = 65; // Insert types\n\nvar INSERT = 1;\nvar UPDATE = 2;\nvar REMOVE = 3;\nvar bson = new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]);\n/**\n * Keeps the state of a unordered batch so we can rewrite the results\n * correctly after command execution\n * @ignore\n */\n\nvar Batch = function Batch(batchType, originalZeroIndex) {\n  _classCallCheck(this, Batch);\n\n  this.originalZeroIndex = originalZeroIndex;\n  this.currentIndex = 0;\n  this.originalIndexes = [];\n  this.batchType = batchType;\n  this.operations = [];\n  this.size = 0;\n  this.sizeBytes = 0;\n};\n/**\n * Wraps a legacy operation so we can correctly rewrite it's error\n * @ignore\n */\n\n\nvar LegacyOp = function LegacyOp(batchType, operation, index) {\n  _classCallCheck(this, LegacyOp);\n\n  this.batchType = batchType;\n  this.index = index;\n  this.operation = operation;\n};\n/**\n * Create a new BulkWriteResult instance (INTERNAL TYPE, do not instantiate directly)\n *\n * @class\n * @return {BulkWriteResult} a BulkWriteResult instance\n */\n\n\nvar BulkWriteResult =\n/*#__PURE__*/\nfunction () {\n  function BulkWriteResult(bulkResult) {\n    _classCallCheck(this, BulkWriteResult);\n\n    this.result = bulkResult;\n  }\n  /**\n   * @return {boolean} ok Did bulk operation correctly execute\n   */\n\n\n  _createClass(BulkWriteResult, [{\n    key: \"getInsertedIds\",\n\n    /**\n     * Return an array of inserted ids\n     *\n     * @return {object[]}\n     */\n    value: function getInsertedIds() {\n      return this.result.insertedIds;\n    }\n    /**\n     * Return an array of upserted ids\n     *\n     * @return {object[]}\n     */\n\n  }, {\n    key: \"getUpsertedIds\",\n    value: function getUpsertedIds() {\n      return this.result.upserted;\n    }\n    /**\n     * Return the upserted id at position x\n     *\n     * @param {number} index the number of the upserted id to return, returns undefined if no result for passed in index\n     * @return {object}\n     */\n\n  }, {\n    key: \"getUpsertedIdAt\",\n    value: function getUpsertedIdAt(index) {\n      return this.result.upserted[index];\n    }\n    /**\n     * Return raw internal result\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"getRawResponse\",\n    value: function getRawResponse() {\n      return this.result;\n    }\n    /**\n     * Returns true if the bulk operation contains a write error\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"hasWriteErrors\",\n    value: function hasWriteErrors() {\n      return this.result.writeErrors.length > 0;\n    }\n    /**\n     * Returns the number of write errors off the bulk operation\n     *\n     * @return {number}\n     */\n\n  }, {\n    key: \"getWriteErrorCount\",\n    value: function getWriteErrorCount() {\n      return this.result.writeErrors.length;\n    }\n    /**\n     * Returns a specific write error object\n     *\n     * @param {number} index of the write error to return, returns null if there is no result for passed in index\n     * @return {WriteError}\n     */\n\n  }, {\n    key: \"getWriteErrorAt\",\n    value: function getWriteErrorAt(index) {\n      if (index < this.result.writeErrors.length) {\n        return this.result.writeErrors[index];\n      }\n\n      return null;\n    }\n    /**\n     * Retrieve all write errors\n     *\n     * @return {object[]}\n     */\n\n  }, {\n    key: \"getWriteErrors\",\n    value: function getWriteErrors() {\n      return this.result.writeErrors;\n    }\n    /**\n     * Retrieve lastOp if available\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"getLastOp\",\n    value: function getLastOp() {\n      return this.result.lastOp;\n    }\n    /**\n     * Retrieve the write concern error if any\n     *\n     * @return {WriteConcernError}\n     */\n\n  }, {\n    key: \"getWriteConcernError\",\n    value: function getWriteConcernError() {\n      if (this.result.writeConcernErrors.length === 0) {\n        return null;\n      } else if (this.result.writeConcernErrors.length === 1) {\n        // Return the error\n        return this.result.writeConcernErrors[0];\n      } else {\n        // Combine the errors\n        var errmsg = '';\n\n        for (var i = 0; i < this.result.writeConcernErrors.length; i++) {\n          var err = this.result.writeConcernErrors[i];\n          errmsg = errmsg + err.errmsg; // TODO: Something better\n\n          if (i === 0) errmsg = errmsg + ' and ';\n        }\n\n        return new WriteConcernError({\n          errmsg: errmsg,\n          code: WRITE_CONCERN_ERROR\n        });\n      }\n    }\n    /**\n     * @return {BulkWriteResult} a BulkWriteResult instance\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.result;\n    }\n    /**\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"BulkWriteResult(\".concat(this.toJSON(this.result), \")\");\n    }\n    /**\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isOk\",\n    value: function isOk() {\n      return this.result.ok === 1;\n    }\n  }, {\n    key: \"ok\",\n    get: function get() {\n      return this.result.ok;\n    }\n    /**\n     * @return {number} nInserted number of inserted documents\n     */\n\n  }, {\n    key: \"nInserted\",\n    get: function get() {\n      return this.result.nInserted;\n    }\n    /**\n     * @return {number} nUpserted Number of upserted documents\n     */\n\n  }, {\n    key: \"nUpserted\",\n    get: function get() {\n      return this.result.nUpserted;\n    }\n    /**\n     * @return {number} nMatched Number of matched documents\n     */\n\n  }, {\n    key: \"nMatched\",\n    get: function get() {\n      return this.result.nMatched;\n    }\n    /**\n     * @return {number} nModified Number of documents updated physically on disk\n     */\n\n  }, {\n    key: \"nModified\",\n    get: function get() {\n      return this.result.nModified;\n    }\n    /**\n     * @return {number} nRemoved Number of removed documents\n     */\n\n  }, {\n    key: \"nRemoved\",\n    get: function get() {\n      return this.result.nRemoved;\n    }\n  }]);\n\n  return BulkWriteResult;\n}();\n/**\n * Create a new WriteConcernError instance (INTERNAL TYPE, do not instantiate directly)\n *\n * @class\n * @return {WriteConcernError} a WriteConcernError instance\n */\n\n\nvar WriteConcernError =\n/*#__PURE__*/\nfunction () {\n  function WriteConcernError(err) {\n    _classCallCheck(this, WriteConcernError);\n\n    this.err = err;\n  }\n  /**\n   * @return {number} code Write concern error code.\n   */\n\n\n  _createClass(WriteConcernError, [{\n    key: \"toJSON\",\n\n    /**\n     * @return {object}\n     */\n    value: function toJSON() {\n      return {\n        code: this.err.code,\n        errmsg: this.err.errmsg\n      };\n    }\n    /**\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"WriteConcernError(\".concat(this.err.errmsg, \")\");\n    }\n  }, {\n    key: \"code\",\n    get: function get() {\n      return this.err.code;\n    }\n    /**\n     * @return {string} errmsg Write concern error message.\n     */\n\n  }, {\n    key: \"errmsg\",\n    get: function get() {\n      return this.err.errmsg;\n    }\n  }]);\n\n  return WriteConcernError;\n}();\n/**\n * Create a new WriteError instance (INTERNAL TYPE, do not instantiate directly)\n *\n * @class\n * @return {WriteConcernError} a WriteConcernError instance\n */\n\n\nvar WriteError =\n/*#__PURE__*/\nfunction () {\n  function WriteError(err) {\n    _classCallCheck(this, WriteError);\n\n    this.err = err;\n  }\n  /**\n   * @return {number} code Write concern error code.\n   */\n\n\n  _createClass(WriteError, [{\n    key: \"getOperation\",\n\n    /**\n     * Define access methods\n     * @return {object}\n     */\n    value: function getOperation() {\n      return this.err.op;\n    }\n    /**\n     * @return {object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        code: this.err.code,\n        index: this.err.index,\n        errmsg: this.err.errmsg,\n        op: this.err.op\n      };\n    }\n    /**\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"WriteError(\".concat(JSON.stringify(this.toJSON()), \")\");\n    }\n  }, {\n    key: \"code\",\n    get: function get() {\n      return this.err.code;\n    }\n    /**\n     * @return {number} index Write concern error original bulk operation index.\n     */\n\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this.err.index;\n    }\n    /**\n     * @return {string} errmsg Write concern error message.\n     */\n\n  }, {\n    key: \"errmsg\",\n    get: function get() {\n      return this.err.errmsg;\n    }\n  }]);\n\n  return WriteError;\n}();\n/**\n * Merges results into shared data structure\n * @ignore\n */\n\n\nfunction mergeBatchResults(ordered, batch, bulkResult, err, result) {\n  // If we have an error set the result to be the err object\n  if (err) {\n    result = err;\n  } else if (result && result.result) {\n    result = result.result;\n  } else if (result == null) {\n    return;\n  } // Do we have a top level error stop processing and return\n\n\n  if (result.ok === 0 && bulkResult.ok === 1) {\n    bulkResult.ok = 0;\n    var writeError = {\n      index: 0,\n      code: result.code || 0,\n      errmsg: result.message,\n      op: batch.operations[0]\n    };\n    bulkResult.writeErrors.push(new WriteError(writeError));\n    return;\n  } else if (result.ok === 0 && bulkResult.ok === 0) {\n    return;\n  } // Deal with opTime if available\n\n\n  if (result.opTime || result.lastOp) {\n    var opTime = result.lastOp || result.opTime;\n    var lastOpTS = null;\n    var lastOpT = null; // We have a time stamp\n\n    if (opTime && opTime._bsontype === 'Timestamp') {\n      if (bulkResult.lastOp == null) {\n        bulkResult.lastOp = opTime;\n      } else if (opTime.greaterThan(bulkResult.lastOp)) {\n        bulkResult.lastOp = opTime;\n      }\n    } else {\n      // Existing TS\n      if (bulkResult.lastOp) {\n        lastOpTS = typeof bulkResult.lastOp.ts === 'number' ? Long.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;\n        lastOpT = typeof bulkResult.lastOp.t === 'number' ? Long.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;\n      } // Current OpTime TS\n\n\n      var opTimeTS = typeof opTime.ts === 'number' ? Long.fromNumber(opTime.ts) : opTime.ts;\n      var opTimeT = typeof opTime.t === 'number' ? Long.fromNumber(opTime.t) : opTime.t; // Compare the opTime's\n\n      if (bulkResult.lastOp == null) {\n        bulkResult.lastOp = opTime;\n      } else if (opTimeTS.greaterThan(lastOpTS)) {\n        bulkResult.lastOp = opTime;\n      } else if (opTimeTS.equals(lastOpTS)) {\n        if (opTimeT.greaterThan(lastOpT)) {\n          bulkResult.lastOp = opTime;\n        }\n      }\n    }\n  } // If we have an insert Batch type\n\n\n  if (batch.batchType === INSERT && result.n) {\n    bulkResult.nInserted = bulkResult.nInserted + result.n;\n  } // If we have an insert Batch type\n\n\n  if (batch.batchType === REMOVE && result.n) {\n    bulkResult.nRemoved = bulkResult.nRemoved + result.n;\n  }\n\n  var nUpserted = 0; // We have an array of upserted values, we need to rewrite the indexes\n\n  if (Array.isArray(result.upserted)) {\n    nUpserted = result.upserted.length;\n\n    for (var i = 0; i < result.upserted.length; i++) {\n      bulkResult.upserted.push({\n        index: result.upserted[i].index + batch.originalZeroIndex,\n        _id: result.upserted[i]._id\n      });\n    }\n  } else if (result.upserted) {\n    nUpserted = 1;\n    bulkResult.upserted.push({\n      index: batch.originalZeroIndex,\n      _id: result.upserted\n    });\n  } // If we have an update Batch type\n\n\n  if (batch.batchType === UPDATE && result.n) {\n    var nModified = result.nModified;\n    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;\n    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);\n\n    if (typeof nModified === 'number') {\n      bulkResult.nModified = bulkResult.nModified + nModified;\n    } else {\n      bulkResult.nModified = null;\n    }\n  }\n\n  if (Array.isArray(result.writeErrors)) {\n    for (var _i = 0; _i < result.writeErrors.length; _i++) {\n      var _writeError = {\n        index: batch.originalZeroIndex + result.writeErrors[_i].index,\n        code: result.writeErrors[_i].code,\n        errmsg: result.writeErrors[_i].errmsg,\n        op: batch.operations[result.writeErrors[_i].index]\n      };\n      bulkResult.writeErrors.push(new WriteError(_writeError));\n    }\n  }\n\n  if (result.writeConcernError) {\n    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));\n  }\n}\n/**\n * handles write concern error\n *\n * @param {object} batch\n * @param {object} bulkResult\n * @param {boolean} ordered\n * @param {WriteConcernError} err\n * @param {function} callback\n */\n\n\nfunction handleMongoWriteConcernError(batch, bulkResult, ordered, err, callback) {\n  mergeBatchResults(ordered, batch, bulkResult, null, err.result);\n  var wrappedWriteConcernError = new WriteConcernError({\n    errmsg: err.result.writeConcernError.errmsg,\n    code: err.result.writeConcernError.result\n  });\n  return handleCallback(callback, new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)), null);\n}\n/**\n * Creates a new BulkWriteError\n *\n * @class\n * @param {Error|string|object} message The error message\n * @param {BulkWriteResult} result The result of the bulk write operation\n * @return {BulkWriteError} A BulkWriteError instance\n * @extends {MongoError}\n */\n\n\nvar BulkWriteError =\n/*#__PURE__*/\nfunction (_MongoError) {\n  _inherits(BulkWriteError, _MongoError);\n\n  function BulkWriteError(error, result) {\n    var _this;\n\n    _classCallCheck(this, BulkWriteError);\n\n    var message = error.err || error.errmsg || error.errMessage || error;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BulkWriteError).call(this, message));\n    Object.assign(_assertThisInitialized(_assertThisInitialized(_this)), error);\n    _this.name = 'BulkWriteError';\n    _this.result = result;\n    return _this;\n  }\n\n  return BulkWriteError;\n}(MongoError);\n/**\n * Handles the find operators for the bulk operations\n * @class\n */\n\n\nvar FindOperators =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {OrderedBulkOperation|UnorderedBulkOperation} bulkOperation\n   */\n  function FindOperators(bulkOperation) {\n    _classCallCheck(this, FindOperators);\n\n    this.s = bulkOperation.s;\n  }\n  /**\n   * Add a single update document to the bulk operation\n   *\n   * @method\n   * @param {object} updateDocument update operations\n   * @throws {MongoError}\n   * @return {OrderedBulkOperation|UnordedBulkOperation}\n   */\n\n\n  _createClass(FindOperators, [{\n    key: \"update\",\n    value: function update(updateDocument) {\n      // Perform upsert\n      var upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false; // Establish the update command\n\n      var document = {\n        q: this.s.currentOp.selector,\n        u: updateDocument,\n        multi: true,\n        upsert: upsert\n      }; // Clear out current Op\n\n      this.s.currentOp = null;\n      return this.s.options.addToOperationsList(this, UPDATE, document);\n    }\n    /**\n     * Add a single update one document to the bulk operation\n     *\n     * @method\n     * @param {object} updateDocument update operations\n     * @throws {MongoError}\n     * @return {OrderedBulkOperation|UnordedBulkOperation}\n     */\n\n  }, {\n    key: \"updateOne\",\n    value: function updateOne(updateDocument) {\n      // Perform upsert\n      var upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false; // Establish the update command\n\n      var document = {\n        q: this.s.currentOp.selector,\n        u: updateDocument,\n        multi: false,\n        upsert: upsert\n      }; // Clear out current Op\n\n      this.s.currentOp = null;\n      return this.s.options.addToOperationsList(this, UPDATE, document);\n    }\n    /**\n     * Add a replace one operation to the bulk operation\n     *\n     * @method\n     * @param {object} updateDocument the new document to replace the existing one with\n     * @throws {MongoError}\n     * @return {OrderedBulkOperation|UnorderedBulkOperation}\n     */\n\n  }, {\n    key: \"replaceOne\",\n    value: function replaceOne(updateDocument) {\n      this.updateOne(updateDocument);\n    }\n    /**\n     * Upsert modifier for update bulk operation\n     *\n     * @method\n     * @throws {MongoError}\n     * @return {FindOperators}\n     */\n\n  }, {\n    key: \"upsert\",\n    value: function upsert() {\n      this.s.currentOp.upsert = true;\n      return this;\n    }\n    /**\n     * Add a delete one operation to the bulk operation\n     *\n     * @method\n     * @throws {MongoError}\n     * @return {OrderedBulkOperation|UnordedBulkOperation}\n     */\n\n  }, {\n    key: \"deleteOne\",\n    value: function deleteOne() {\n      // Establish the update command\n      var document = {\n        q: this.s.currentOp.selector,\n        limit: 1\n      }; // Clear out current Op\n\n      this.s.currentOp = null;\n      return this.s.options.addToOperationsList(this, REMOVE, document);\n    }\n    /**\n     * Add a delete operation to the bulk operation\n     *\n     * @method\n     * @throws {MongoError}\n     * @return {OrderedBulkOperation|UnordedBulkOperation}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      // Establish the update command\n      var document = {\n        q: this.s.currentOp.selector,\n        limit: 0\n      }; // Clear out current Op\n\n      this.s.currentOp = null;\n      return this.s.options.addToOperationsList(this, REMOVE, document);\n    }\n    /**\n     * backwards compatability for deleteOne\n     */\n\n  }, {\n    key: \"removeOne\",\n    value: function removeOne() {\n      return this.deleteOne();\n    }\n    /**\n     * backwards compatability for delete\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      return this.delete();\n    }\n  }]);\n\n  return FindOperators;\n}();\n/**\n * Parent class to OrderedBulkOperation and UnorderedBulkOperation\n * @class\n */\n\n\nvar BulkOperationBase =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a new OrderedBulkOperation or UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\n   * @class\n   * @property {number} length Get the number of operations in the bulk.\n   * @return {OrderedBulkOperation|UnordedBulkOperation}\n   */\n  function BulkOperationBase(topology, collection, options, isOrdered) {\n    _classCallCheck(this, BulkOperationBase);\n\n    // determine whether bulkOperation is ordered or unordered\n    this.isOrdered = isOrdered;\n    options = options == null ? {} : options; // TODO Bring from driver information in isMaster\n    // Get the namespace for the write operations\n\n    var namespace = collection.collectionName; // Used to mark operation as executed\n\n    var executed = false; // Current item\n\n    var currentOp = null; // Handle to the bson serializer, used to calculate running sizes\n\n    var bson = topology.bson; // Set max byte size\n\n    var isMaster = topology.lastIsMaster();\n    var maxBatchSizeBytes = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;\n    var maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1000; // Final options for retryable writes and write concern\n\n    var finalOptions = Object.assign({}, options);\n    finalOptions = applyRetryableWrites(finalOptions, collection.s.db);\n    finalOptions = applyWriteConcern(finalOptions, {\n      collection: collection\n    }, options);\n    var writeConcern = finalOptions.writeConcern; // Get the promiseLibrary\n\n    var promiseLibrary = options.promiseLibrary || Promise; // Final results\n\n    var bulkResult = {\n      ok: 1,\n      writeErrors: [],\n      writeConcernErrors: [],\n      insertedIds: [],\n      nInserted: 0,\n      nUpserted: 0,\n      nMatched: 0,\n      nModified: 0,\n      nRemoved: 0,\n      upserted: []\n    }; // Internal state\n\n    this.s = {\n      // Final result\n      bulkResult: bulkResult,\n      // Current batch state\n      currentBatch: null,\n      currentIndex: 0,\n      // ordered specific\n      currentBatchSize: 0,\n      currentBatchSizeBytes: 0,\n      // unordered specific\n      currentInsertBatch: null,\n      currentUpdateBatch: null,\n      currentRemoveBatch: null,\n      batches: [],\n      // Write concern\n      writeConcern: writeConcern,\n      // Max batch size options\n      maxBatchSizeBytes: maxBatchSizeBytes,\n      maxWriteBatchSize: maxWriteBatchSize,\n      // Namespace\n      namespace: namespace,\n      // BSON\n      bson: bson,\n      // Topology\n      topology: topology,\n      // Options\n      options: finalOptions,\n      // Current operation\n      currentOp: currentOp,\n      // Executed\n      executed: executed,\n      // Collection\n      collection: collection,\n      // Promise Library\n      promiseLibrary: promiseLibrary,\n      // Fundamental error\n      err: null,\n      // check keys\n      checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : true\n    }; // bypass Validation\n\n    if (options.bypassDocumentValidation === true) {\n      this.s.bypassDocumentValidation = true;\n    }\n  }\n  /**\n   * Add a single insert document to the bulk operation\n   *\n   * @param {object} document the document to insert\n   * @throws {MongoError}\n   * @return {OrderedBulkOperation|UnorderedBulkOperation}\n   */\n\n\n  _createClass(BulkOperationBase, [{\n    key: \"insert\",\n    value: function insert(document) {\n      if (this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null) document._id = new ObjectID();\n      return this.s.options.addToOperationsList(this, INSERT, document);\n    }\n    /**\n     * Initiate a find operation for an update/updateOne/remove/removeOne/replaceOne\n     *\n     * @method\n     * @param {object} selector The selector for the bulk operation.\n     * @throws {MongoError}\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(selector) {\n      if (!selector) {\n        throw toError('Bulk find operation must specify a selector');\n      } // Save a current selector\n\n\n      this.s.currentOp = {\n        selector: selector\n      };\n      return new FindOperators(this);\n    }\n    /**\n     * Raw performs the bulk operation\n     *\n     * @method\n     * @param {object} op operation\n     * @return {OrderedBulkOperation|UnorderedBulkOperation}\n     */\n\n  }, {\n    key: \"raw\",\n    value: function raw(op) {\n      var key = Object.keys(op)[0]; // Set up the force server object id\n\n      var forceServerObjectId = typeof this.s.options.forceServerObjectId === 'boolean' ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId; // Update operations\n\n      if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {\n        op[key].multi = op.updateOne || op.replaceOne ? false : true;\n        return this.s.options.addToOperationsList(this, UPDATE, op[key]);\n      } // Crud spec update format\n\n\n      if (op.updateOne || op.updateMany || op.replaceOne) {\n        var multi = op.updateOne || op.replaceOne ? false : true;\n        var operation = {\n          q: op[key].filter,\n          u: op[key].update || op[key].replacement,\n          multi: multi\n        };\n\n        if (this.isOrdered) {\n          operation.upsert = op[key].upsert ? true : false;\n          if (op.collation) operation.collation = op.collation;\n        } else {\n          if (op[key].upsert) operation.upsert = true;\n        }\n\n        if (op[key].arrayFilters) operation.arrayFilters = op[key].arrayFilters;\n        return this.s.options.addToOperationsList(this, UPDATE, operation);\n      } // Remove operations\n\n\n      if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {\n        op[key].limit = op.removeOne ? 1 : 0;\n        return this.s.options.addToOperationsList(this, REMOVE, op[key]);\n      } // Crud spec delete operations, less efficient\n\n\n      if (op.deleteOne || op.deleteMany) {\n        var limit = op.deleteOne ? 1 : 0;\n        var _operation = {\n          q: op[key].filter,\n          limit: limit\n        };\n\n        if (this.isOrdered) {\n          if (op.collation) _operation.collation = op.collation;\n        }\n\n        return this.s.options.addToOperationsList(this, REMOVE, _operation);\n      } // Insert operations\n\n\n      if (op.insertOne && op.insertOne.document == null) {\n        if (forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();\n        return this.s.options.addToOperationsList(this, INSERT, op.insertOne);\n      } else if (op.insertOne && op.insertOne.document) {\n        if (forceServerObjectId !== true && op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();\n        return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);\n      }\n\n      if (op.insertMany) {\n        for (var i = 0; i < op.insertMany.length; i++) {\n          if (forceServerObjectId !== true && op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();\n          this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);\n        }\n\n        return;\n      } // No valid type of operation\n\n\n      throw toError('bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany');\n    }\n    /**\n     * Execute next write command in a chain\n     *\n     * @method\n     * @param {class} bulk either OrderedBulkOperation or UnorderdBulkOperation\n     * @param {object} writeConcern\n     * @param {object} options\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"bulkExecute\",\n    value: function bulkExecute(_writeConcern, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = options || {};\n\n      if (this.s.executed) {\n        var executedError = toError('batch cannot be re-executed');\n        return typeof callback === 'function' ? callback(executedError, null) : this.s.promiseLibrary.reject(executedError);\n      }\n\n      if (typeof _writeConcern === 'function') {\n        callback = _writeConcern;\n      } else if (_writeConcern && typeof _writeConcern === 'object') {\n        this.s.writeConcern = _writeConcern;\n      } // If we have current batch\n\n\n      if (this.isOrdered) {\n        if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch);\n      } else {\n        if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);\n        if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);\n        if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);\n      } // If we have no operations in the bulk raise an error\n\n\n      if (this.s.batches.length === 0) {\n        var emptyBatchError = toError('Invalid Operation, no operations specified');\n        return typeof callback === 'function' ? callback(emptyBatchError, null) : this.s.promiseLibrary.reject(emptyBatchError);\n      }\n\n      return {\n        options: options,\n        callback: callback\n      };\n    }\n    /**\n     * Handles final options before executing command\n     *\n     * @param {object} config\n     * @param {object} config.options\n     * @param {number} config.batch\n     * @param {function} config.resultHandler\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"finalOptionsHandler\",\n    value: function finalOptionsHandler(config, callback) {\n      var finalOptions = Object.assign({\n        ordered: this.isOrdered\n      }, config.options);\n\n      if (this.s.writeConcern != null) {\n        finalOptions.writeConcern = this.s.writeConcern;\n      }\n\n      if (finalOptions.bypassDocumentValidation !== true) {\n        delete finalOptions.bypassDocumentValidation;\n      } // Set an operationIf if provided\n\n\n      if (this.operationId) {\n        config.resultHandler.operationId = this.operationId;\n      } // Serialize functions\n\n\n      if (this.s.options.serializeFunctions) {\n        finalOptions.serializeFunctions = true;\n      } // Ignore undefined\n\n\n      if (this.s.options.ignoreUndefined) {\n        finalOptions.ignoreUndefined = true;\n      } // Is the bypassDocumentValidation options specific\n\n\n      if (this.s.bypassDocumentValidation === true) {\n        finalOptions.bypassDocumentValidation = true;\n      } // Is the checkKeys option disabled\n\n\n      if (this.s.checkKeys === false) {\n        finalOptions.checkKeys = false;\n      }\n\n      if (finalOptions.retryWrites) {\n        if (config.batch.batchType === UPDATE) {\n          finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some(function (op) {\n            return op.multi;\n          });\n        }\n\n        if (config.batch.batchType === REMOVE) {\n          finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some(function (op) {\n            return op.limit === 0;\n          });\n        }\n      }\n\n      try {\n        if (config.batch.batchType === INSERT) {\n          this.s.topology.insert(this.s.collection.namespace, config.batch.operations, finalOptions, config.resultHandler);\n        } else if (config.batch.batchType === UPDATE) {\n          this.s.topology.update(this.s.collection.namespace, config.batch.operations, finalOptions, config.resultHandler);\n        } else if (config.batch.batchType === REMOVE) {\n          this.s.topology.remove(this.s.collection.namespace, config.batch.operations, finalOptions, config.resultHandler);\n        }\n      } catch (err) {\n        // Force top level error\n        err.ok = 0; // Merge top level error and return\n\n        handleCallback(callback, null, mergeBatchResults(false, config.batch, this.s.bulkResult, err, null));\n      }\n    }\n    /**\n     * Handles the write error before executing commands\n     *\n     * @param {function} callback\n     * @param {BulkWriteResult} writeResult\n     * @param {class} self either OrderedBulkOperation or UnorderdBulkOperation\n     */\n\n  }, {\n    key: \"handleWriteError\",\n    value: function handleWriteError(callback, writeResult) {\n      if (this.s.bulkResult.writeErrors.length > 0) {\n        if (this.s.bulkResult.writeErrors.length === 1) {\n          handleCallback(callback, new BulkWriteError(toError(this.s.bulkResult.writeErrors[0]), writeResult), null);\n          return true;\n        }\n\n        handleCallback(callback, new BulkWriteError(toError({\n          message: 'write operation failed',\n          code: this.s.bulkResult.writeErrors[0].code,\n          writeErrors: this.s.bulkResult.writeErrors\n        }), writeResult), null);\n        return true;\n      } else if (writeResult.getWriteConcernError()) {\n        handleCallback(callback, new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult), null);\n        return true;\n      }\n    }\n  }]);\n\n  return BulkOperationBase;\n}();\n\nObject.defineProperty(BulkOperationBase.prototype, 'length', {\n  enumerable: true,\n  get: function get() {\n    return this.s.currentIndex;\n  }\n}); // Exports symbols\n\nmodule.exports = {\n  Batch: Batch,\n  BulkOperationBase: BulkOperationBase,\n  BulkWriteError: BulkWriteError,\n  BulkWriteResult: BulkWriteResult,\n  bson: bson,\n  FindOperators: FindOperators,\n  handleMongoWriteConcernError: handleMongoWriteConcernError,\n  LegacyOp: LegacyOp,\n  mergeBatchResults: mergeBatchResults,\n  INVALID_BSON_ERROR: INVALID_BSON_ERROR,\n  MULTIPLE_ERROR: MULTIPLE_ERROR,\n  UNKNOWN_ERROR: UNKNOWN_ERROR,\n  WRITE_CONCERN_ERROR: WRITE_CONCERN_ERROR,\n  INSERT: INSERT,\n  UPDATE: UPDATE,\n  REMOVE: REMOVE,\n  WriteError: WriteError,\n  WriteConcernError: WriteConcernError\n};","map":null,"metadata":{},"sourceType":"script"}