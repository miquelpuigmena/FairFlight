{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/inherits\");\n\nvar common = require('./common');\n\nvar BulkOperationBase = common.BulkOperationBase;\n\nvar utils = require('../utils');\n\nvar toError = utils.toError;\nvar handleCallback = utils.handleCallback;\nvar BulkWriteResult = common.BulkWriteResult;\nvar Batch = common.Batch;\nvar mergeBatchResults = common.mergeBatchResults;\nvar executeOperation = utils.executeOperation;\n\nvar MongoWriteConcernError = require('mongodb-core').MongoWriteConcernError;\n\nvar handleMongoWriteConcernError = require('./common').handleMongoWriteConcernError;\n\nvar bson = common.bson;\n/**\n * Add to internal list of Operations\n *\n * @param {OrderedBulkOperation} bulkOperation\n * @param {number} docType number indicating the document type\n * @param {object} document\n * @return {OrderedBulkOperation}\n */\n\nfunction addToOperationsList(bulkOperation, docType, document) {\n  // Get the bsonSize\n  var bsonSize = bson.calculateObjectSize(document, {\n    checkKeys: false\n  }); // Throw error if the doc is bigger than the max BSON size\n\n  if (bsonSize >= bulkOperation.s.maxBatchSizeBytes) throw toError('document is larger than the maximum size ' + bulkOperation.s.maxBatchSizeBytes); // Create a new batch object if we don't have a current one\n\n  if (bulkOperation.s.currentBatch == null) bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex); // Check if we need to create a new batch\n\n  if (bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatchSizeBytes + bulkOperation.s.currentBatchSizeBytes >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {\n    // Save the batch to the execution stack\n    bulkOperation.s.batches.push(bulkOperation.s.currentBatch); // Create a new batch\n\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex); // Reset the current size trackers\n\n    bulkOperation.s.currentBatchSize = 0;\n    bulkOperation.s.currentBatchSizeBytes = 0;\n  } else {\n    // Update current batch size\n    bulkOperation.s.currentBatchSize = bulkOperation.s.currentBatchSize + 1;\n    bulkOperation.s.currentBatchSizeBytes = bulkOperation.s.currentBatchSizeBytes + bsonSize;\n  }\n\n  if (docType === common.INSERT) {\n    bulkOperation.s.bulkResult.insertedIds.push({\n      index: bulkOperation.s.currentIndex,\n      _id: document._id\n    });\n  } // We have an array of documents\n\n\n  if (Array.isArray(document)) {\n    throw toError('operation passed in cannot be an Array');\n  } else {\n    bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);\n    bulkOperation.s.currentBatch.operations.push(document);\n    bulkOperation.s.currentBatchSizeBytes = bulkOperation.s.currentBatchSizeBytes + bsonSize;\n    bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;\n  } // Return bulkOperation\n\n\n  return bulkOperation;\n}\n/**\n * Create a new OrderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @property {number} length Get the number of operations in the bulk.\n * @return {OrderedBulkOperation} a OrderedBulkOperation instance.\n */\n\n\nvar OrderedBulkOperation =\n/*#__PURE__*/\nfunction (_BulkOperationBase) {\n  _inherits(OrderedBulkOperation, _BulkOperationBase);\n\n  function OrderedBulkOperation(topology, collection, options) {\n    _classCallCheck(this, OrderedBulkOperation);\n\n    options = options || {};\n    options = Object.assign(options, {\n      addToOperationsList: addToOperationsList\n    });\n    return _possibleConstructorReturn(this, _getPrototypeOf(OrderedBulkOperation).call(this, topology, collection, options, true));\n  }\n  /**\n   * The callback format for results\n   * @callback OrderedBulkOperation~resultCallback\n   * @param {MongoError} error An error instance representing the error during the execution.\n   * @param {BulkWriteResult} result The bulk write result.\n   */\n\n  /**\n   * Execute the ordered bulk operation\n   *\n   * @method\n   * @param {object} [options] Optional settings.\n   * @param {(number|string)} [options.w] The write concern.\n   * @param {number} [options.wtimeout] The write concern timeout.\n   * @param {boolean} [options.j=false] Specify a journal write concern.\n   * @param {boolean} [options.fsync=false] Specify a file sync write concern.\n   * @param {OrderedBulkOperation~resultCallback} [callback] The result callback\n   * @throws {MongoError}\n   * @return {Promise} returns Promise if no callback passed\n   */\n\n\n  _createClass(OrderedBulkOperation, [{\n    key: \"execute\",\n    value: function execute(_writeConcern, options, callback) {\n      var ret = this.bulkExecute(_writeConcern, options, callback);\n      options = ret.options;\n      callback = ret.callback;\n      return executeOperation(this.s.topology, executeCommands, [this, options, callback]);\n    }\n  }]);\n\n  return OrderedBulkOperation;\n}(BulkOperationBase);\n/**\n * Execute next write command in a chain\n *\n * @param {OrderedBulkOperation} bulkOperation\n * @param {object} options\n * @param {function} callback\n */\n\n\nfunction executeCommands(bulkOperation, options, callback) {\n  if (bulkOperation.s.batches.length === 0) {\n    return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));\n  } // Ordered execution of the command\n\n\n  var batch = bulkOperation.s.batches.shift();\n\n  function resultHandler(err, result) {\n    // Error is a driver related error not a bulk op error, terminate\n    if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {\n      return handleCallback(callback, err);\n    } // If we have and error\n\n\n    if (err) err.ok = 0;\n\n    if (err instanceof MongoWriteConcernError) {\n      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, true, err, callback);\n    } // Merge the results together\n\n\n    var writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);\n    var mergeResult = mergeBatchResults(true, batch, bulkOperation.s.bulkResult, err, result);\n\n    if (mergeResult != null) {\n      return handleCallback(callback, null, writeResult);\n    }\n\n    if (bulkOperation.handleWriteError(callback, writeResult)) return; // Execute the next command in line\n\n    executeCommands(bulkOperation, options, callback);\n  }\n\n  bulkOperation.finalOptionsHandler({\n    options: options,\n    batch: batch,\n    resultHandler: resultHandler\n  }, callback);\n}\n/**\n * Returns an unordered batch object\n * @ignore\n */\n\n\nfunction initializeOrderedBulkOp(topology, collection, options) {\n  return new OrderedBulkOperation(topology, collection, options);\n}\n\ninitializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;\nmodule.exports = initializeOrderedBulkOp;\nmodule.exports.Bulk = OrderedBulkOperation;","map":null,"metadata":{},"sourceType":"script"}