{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/inherits\");\n\nvar f = require('util').format,\n    crypto = require('crypto'),\n    retrieveBSON = require('../connection/utils').retrieveBSON,\n    Query = require('../connection/commands').Query,\n    MongoError = require('../error').MongoError,\n    Buffer = require('safe-buffer').Buffer;\n\nvar saslprep;\n\ntry {\n  saslprep = require('saslprep');\n} catch (e) {// don't do anything;\n}\n\nvar BSON = retrieveBSON(),\n    Binary = BSON.Binary;\n\nvar AuthSession = function AuthSession(db, username, password) {\n  this.db = db;\n  this.username = username;\n  this.password = password;\n};\n\nAuthSession.prototype.equal = function (session) {\n  return session.db === this.db && session.username === this.username && session.password === this.password;\n};\n\nvar id = 0;\n/**\n * Creates a new ScramSHA authentication mechanism\n * @class\n * @return {ScramSHA} A cursor instance\n */\n\nvar ScramSHA = function ScramSHA(bson, cryptoMethod) {\n  this.bson = bson;\n  this.authStore = [];\n  this.id = id++;\n  this.cryptoMethod = cryptoMethod || 'sha1';\n};\n\nvar parsePayload = function parsePayload(payload) {\n  var dict = {};\n  var parts = payload.split(',');\n\n  for (var i = 0; i < parts.length; i++) {\n    var valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n};\n\nvar passwordDigest = function passwordDigest(username, password) {\n  if (typeof username !== 'string') throw new MongoError('username must be a string');\n  if (typeof password !== 'string') throw new MongoError('password must be a string');\n  if (password.length === 0) throw new MongoError('password cannot be empty'); // Use node md5 generator\n\n  var md5 = crypto.createHash('md5'); // Generate keys used for authentication\n\n  md5.update(username + ':mongo:' + password, 'utf8');\n  return md5.digest('hex');\n}; // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) a = Buffer.from(a);\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b);\n  var length = Math.max(a.length, b.length);\n  var res = [];\n\n  for (var i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nvar _hiCache = {};\nvar _hiCacheCount = 0;\n\nvar _hiCachePurge = function _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n};\n\nvar hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  var key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n/**\n * Authenticate\n * @method\n * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on\n * @param {[]Connections} connections Connections to authenticate using this authenticator\n * @param {string} db Name of the database\n * @param {string} username Username\n * @param {string} password Password\n * @param {authResultCallback} callback The callback to return the result from the authentication\n * @return {object}\n */\n\n\nScramSHA.prototype.auth = function (server, connections, db, username, password, callback) {\n  var self = this; // Total connections\n\n  var count = connections.length;\n  if (count === 0) return callback(null, null); // Valid connections\n\n  var numberOfValidConnections = 0;\n  var errorObject = null;\n  var cryptoMethod = this.cryptoMethod;\n  var mechanism = 'SCRAM-SHA-1';\n  var processedPassword;\n\n  if (cryptoMethod === 'sha256') {\n    mechanism = 'SCRAM-SHA-256';\n    var saslprepFn = server.s && server.s.saslprep || saslprep;\n\n    if (saslprepFn) {\n      processedPassword = saslprepFn(password);\n    } else {\n      console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n      processedPassword = password;\n    }\n  } else {\n    processedPassword = passwordDigest(username, password);\n  } // Execute MongoCR\n\n\n  var executeScram = function executeScram(connection) {\n    // Clean up the user\n    username = username.replace('=', '=3D').replace(',', '=2C'); // Create a random nonce\n\n    var nonce = crypto.randomBytes(24).toString('base64'); // var nonce = 'MsQUY9iw0T9fx2MUEz6LZPwGuhVvWAhc'\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n\n    var firstBare = Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce, 'utf8')]); // Build command structure\n\n    var cmd = {\n      saslStart: 1,\n      mechanism: mechanism,\n      payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), firstBare])),\n      autoAuthorize: 1\n    }; // Handle the error\n\n    var handleError = function handleError(err, r) {\n      if (err) {\n        numberOfValidConnections = numberOfValidConnections - 1;\n        errorObject = err;\n        return false;\n      } else if (r.result['$err']) {\n        errorObject = r.result;\n        return false;\n      } else if (r.result['errmsg']) {\n        errorObject = r.result;\n        return false;\n      } else {\n        numberOfValidConnections = numberOfValidConnections + 1;\n      }\n\n      return true;\n    }; // Finish up\n\n\n    var finish = function finish(_count, _numberOfValidConnections) {\n      if (_count === 0 && _numberOfValidConnections > 0) {\n        // Store the auth details\n        addAuthSession(self.authStore, new AuthSession(db, username, password)); // Return correct authentication\n\n        return callback(null, true);\n      } else if (_count === 0) {\n        if (errorObject == null) errorObject = new MongoError(f('failed to authenticate using scram'));\n        return callback(errorObject, false);\n      }\n    };\n\n    var handleEnd = function handleEnd(_err, _r) {\n      // Handle any error\n      handleError(_err, _r); // Adjust the number of connections\n\n      count = count - 1; // Execute the finish\n\n      finish(count, numberOfValidConnections);\n    }; // Write the commmand on the connection\n\n\n    server(connection, new Query(self.bson, f('%s.$cmd', db), cmd, {\n      numberToSkip: 0,\n      numberToReturn: 1\n    }), function (err, r) {\n      // Do we have an error, handle it\n      if (handleError(err, r) === false) {\n        count = count - 1;\n\n        if (count === 0 && numberOfValidConnections > 0) {\n          // Store the auth details\n          addAuthSession(self.authStore, new AuthSession(db, username, password)); // Return correct authentication\n\n          return callback(null, true);\n        } else if (count === 0) {\n          if (errorObject == null) errorObject = new MongoError(f('failed to authenticate using scram'));\n          return callback(errorObject, false);\n        }\n\n        return;\n      } // Get the dictionary\n\n\n      var dict = parsePayload(r.result.payload.value()); // Unpack dictionary\n\n      var iterations = parseInt(dict.i, 10);\n      var salt = dict.s;\n      var rnonce = dict.r; // Set up start of proof\n\n      var withoutProof = f('c=biws,r=%s', rnonce);\n      var saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n\n      if (iterations && iterations < 4096) {\n        var error = new MongoError(\"Server returned an invalid iteration count \".concat(iterations));\n        return callback(error, false);\n      } // Create the client key\n\n\n      var clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key'); // Create the stored key\n\n      var storedKey = H(cryptoMethod, clientKey); // Create the authentication message\n\n      var authMessage = [firstBare, r.result.payload.value().toString('base64'), withoutProof].join(','); // Create client signature\n\n      var clientSignature = HMAC(cryptoMethod, storedKey, authMessage); // Create client proof\n\n      var clientProof = f('p=%s', xor(clientKey, clientSignature)); // Create client final\n\n      var clientFinal = [withoutProof, clientProof].join(','); // Create continue message\n\n      var cmd = {\n        saslContinue: 1,\n        conversationId: r.result.conversationId,\n        payload: new Binary(Buffer.from(clientFinal))\n      }; //\n      // Execute sasl continue\n      // Write the commmand on the connection\n\n      server(connection, new Query(self.bson, f('%s.$cmd', db), cmd, {\n        numberToSkip: 0,\n        numberToReturn: 1\n      }), function (err, r) {\n        if (r && r.result.done === false) {\n          var cmd = {\n            saslContinue: 1,\n            conversationId: r.result.conversationId,\n            payload: Buffer.alloc(0)\n          }; // Write the commmand on the connection\n\n          server(connection, new Query(self.bson, f('%s.$cmd', db), cmd, {\n            numberToSkip: 0,\n            numberToReturn: 1\n          }), function (err, r) {\n            handleEnd(err, r);\n          });\n        } else {\n          handleEnd(err, r);\n        }\n      });\n    });\n  };\n\n  var _execute = function _execute(_connection) {\n    process.nextTick(function () {\n      executeScram(_connection);\n    });\n  }; // For each connection we need to authenticate\n\n\n  while (connections.length > 0) {\n    _execute(connections.shift());\n  }\n}; // Add to store only if it does not exist\n\n\nvar addAuthSession = function addAuthSession(authStore, session) {\n  var found = false;\n\n  for (var i = 0; i < authStore.length; i++) {\n    if (authStore[i].equal(session)) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) authStore.push(session);\n};\n/**\n * Remove authStore credentials\n * @method\n * @param {string} db Name of database we are removing authStore details about\n * @return {object}\n */\n\n\nScramSHA.prototype.logout = function (dbName) {\n  this.authStore = this.authStore.filter(function (x) {\n    return x.db !== dbName;\n  });\n};\n/**\n * Re authenticate pool\n * @method\n * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on\n * @param {[]Connections} connections Connections to authenticate using this authenticator\n * @param {authResultCallback} callback The callback to return the result from the authentication\n * @return {object}\n */\n\n\nScramSHA.prototype.reauthenticate = function (server, connections, callback) {\n  var authStore = this.authStore.slice(0);\n  var count = authStore.length; // No connections\n\n  if (count === 0) return callback(null, null); // Iterate over all the auth details stored\n\n  for (var i = 0; i < authStore.length; i++) {\n    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function (err) {\n      count = count - 1; // Done re-authenticating\n\n      if (count === 0) {\n        callback(err, null);\n      }\n    });\n  }\n};\n\nvar ScramSHA1 =\n/*#__PURE__*/\nfunction (_ScramSHA) {\n  _inherits(ScramSHA1, _ScramSHA);\n\n  function ScramSHA1(bson) {\n    _classCallCheck(this, ScramSHA1);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA1).call(this, bson, 'sha1'));\n  }\n\n  return ScramSHA1;\n}(ScramSHA);\n\nvar ScramSHA256 =\n/*#__PURE__*/\nfunction (_ScramSHA2) {\n  _inherits(ScramSHA256, _ScramSHA2);\n\n  function ScramSHA256(bson) {\n    _classCallCheck(this, ScramSHA256);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA256).call(this, bson, 'sha256'));\n  }\n\n  return ScramSHA256;\n}(ScramSHA);\n\nmodule.exports = {\n  ScramSHA1: ScramSHA1,\n  ScramSHA256: ScramSHA256\n};","map":null,"metadata":{},"sourceType":"script"}