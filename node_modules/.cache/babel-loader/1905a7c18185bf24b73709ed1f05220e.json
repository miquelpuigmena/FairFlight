{"ast":null,"code":"'use strict';\n\nvar buildCountCommand = require('./collection_ops').buildCountCommand;\n\nvar formattedOrderClause = require('../utils').formattedOrderClause;\n\nvar handleCallback = require('../utils').handleCallback;\n\nvar MongoError = require('mongodb-core').MongoError;\n\nvar push = Array.prototype.push;\n/**\n * Get the count of documents for this cursor.\n *\n * @method\n * @param {Cursor} cursor The Cursor instance on which to count.\n * @param {boolean} [applySkipLimit=true] Specifies whether the count command apply limit and skip settings should be applied on the cursor or in the provided options.\n * @param {object} [options] Optional settings. See Cursor.prototype.count for a list of options.\n * @param {Cursor~countResultCallback} [callback] The result callback.\n */\n\nfunction count(cursor, applySkipLimit, opts, callback) {\n  if (applySkipLimit) {\n    if (typeof cursor.cursorSkip() === 'number') opts.skip = cursor.cursorSkip();\n    if (typeof cursor.cursorLimit() === 'number') opts.limit = cursor.cursorLimit();\n  } // Ensure we have the right read preference inheritance\n\n\n  if (opts.readPreference) {\n    cursor.setReadPreference(opts.readPreference);\n  }\n\n  if (typeof opts.maxTimeMS !== 'number' && cursor.s.cmd && typeof cursor.s.cmd.maxTimeMS === 'number') {\n    opts.maxTimeMS = cursor.s.cmd.maxTimeMS;\n  }\n\n  var options = {};\n  options.skip = opts.skip;\n  options.limit = opts.limit;\n  options.hint = opts.hint;\n  options.maxTimeMS = opts.maxTimeMS; // Command\n\n  var delimiter = cursor.s.ns.indexOf('.');\n  options.collectionName = cursor.s.ns.substr(delimiter + 1);\n  var command;\n\n  try {\n    command = buildCountCommand(cursor, cursor.s.cmd.query, options);\n  } catch (err) {\n    return callback(err);\n  } // Set cursor server to the same as the topology\n\n\n  cursor.server = cursor.topology.s.coreTopology; // Execute the command\n\n  cursor.s.topology.command(\"\".concat(cursor.s.ns.substr(0, delimiter), \".$cmd\"), command, cursor.s.options, function (err, result) {\n    callback(err, result ? result.result.n : null);\n  });\n}\n/**\n * Iterates over all the documents for this cursor. See Cursor.prototype.each for more information.\n *\n * @method\n * @deprecated\n * @param {Cursor} cursor The Cursor instance on which to run.\n * @param {Cursor~resultCallback} callback The result callback.\n */\n\n\nfunction each(cursor, callback) {\n  var Cursor = require('../cursor');\n\n  if (!callback) throw MongoError.create({\n    message: 'callback is mandatory',\n    driver: true\n  });\n  if (cursor.isNotified()) return;\n\n  if (cursor.s.state === Cursor.CLOSED || cursor.isDead()) {\n    return handleCallback(callback, MongoError.create({\n      message: 'Cursor is closed',\n      driver: true\n    }));\n  }\n\n  if (cursor.s.state === Cursor.INIT) cursor.s.state = Cursor.OPEN; // Define function to avoid global scope escape\n\n  var fn = null; // Trampoline all the entries\n\n  if (cursor.bufferedCount() > 0) {\n    while (fn = loop(cursor, callback)) {\n      fn(cursor, callback);\n    }\n\n    each(cursor, callback);\n  } else {\n    cursor.next(function (err, item) {\n      if (err) return handleCallback(callback, err);\n\n      if (item == null) {\n        return cursor.close({\n          skipKillCursors: true\n        }, function () {\n          return handleCallback(callback, null, null);\n        });\n      }\n\n      if (handleCallback(callback, null, item) === false) return;\n      each(cursor, callback);\n    });\n  }\n}\n/**\n * Check if there is any document still available in the cursor.\n *\n * @method\n * @param {Cursor} cursor The Cursor instance on which to run.\n * @param {Cursor~resultCallback} [callback] The result callback.\n */\n\n\nfunction hasNext(cursor, callback) {\n  var Cursor = require('../cursor');\n\n  if (cursor.s.currentDoc) {\n    return callback(null, true);\n  }\n\n  if (cursor.isNotified()) {\n    return callback(null, false);\n  }\n\n  nextObject(cursor, function (err, doc) {\n    if (err) return callback(err, null);\n    if (cursor.s.state === Cursor.CLOSED || cursor.isDead()) return callback(null, false);\n    if (!doc) return callback(null, false);\n    cursor.s.currentDoc = doc;\n    callback(null, true);\n  });\n} // Trampoline emptying the number of retrieved items\n// without incurring a nextTick operation\n\n\nfunction loop(cursor, callback) {\n  // No more items we are done\n  if (cursor.bufferedCount() === 0) return; // Get the next document\n\n  cursor._next(callback); // Loop\n\n\n  return loop;\n}\n/**\n * Get the next available document from the cursor. Returns null if no more documents are available.\n *\n * @method\n * @param {Cursor} cursor The Cursor instance from which to get the next document.\n * @param {Cursor~resultCallback} [callback] The result callback.\n */\n\n\nfunction next(cursor, callback) {\n  // Return the currentDoc if someone called hasNext first\n  if (cursor.s.currentDoc) {\n    var doc = cursor.s.currentDoc;\n    cursor.s.currentDoc = null;\n    return callback(null, doc);\n  } // Return the next object\n\n\n  nextObject(cursor, callback);\n} // Get the next available document from the cursor, returns null if no more documents are available.\n\n\nfunction nextObject(cursor, callback) {\n  var Cursor = require('../cursor');\n\n  if (cursor.s.state === Cursor.CLOSED || cursor.isDead && cursor.isDead()) return handleCallback(callback, MongoError.create({\n    message: 'Cursor is closed',\n    driver: true\n  }));\n\n  if (cursor.s.state === Cursor.INIT && cursor.s.cmd.sort) {\n    try {\n      cursor.s.cmd.sort = formattedOrderClause(cursor.s.cmd.sort);\n    } catch (err) {\n      return handleCallback(callback, err);\n    }\n  } // Get the next object\n\n\n  cursor._next(function (err, doc) {\n    cursor.s.state = Cursor.OPEN;\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, doc);\n  });\n}\n/**\n * Returns an array of documents. See Cursor.prototype.toArray for more information.\n *\n * @method\n * @param {Cursor} cursor The Cursor instance from which to get the next document.\n * @param {Cursor~toArrayResultCallback} [callback] The result callback.\n */\n\n\nfunction toArray(cursor, callback) {\n  var Cursor = require('../cursor');\n\n  var items = []; // Reset cursor\n\n  cursor.rewind();\n  cursor.s.state = Cursor.INIT; // Fetch all the documents\n\n  var fetchDocs = function fetchDocs() {\n    cursor._next(function (err, doc) {\n      if (err) {\n        return cursor._endSession ? cursor._endSession(function () {\n          return handleCallback(callback, err);\n        }) : handleCallback(callback, err);\n      }\n\n      if (doc == null) {\n        return cursor.close({\n          skipKillCursors: true\n        }, function () {\n          return handleCallback(callback, null, items);\n        });\n      } // Add doc to items\n\n\n      items.push(doc); // Get all buffered objects\n\n      if (cursor.bufferedCount() > 0) {\n        var docs = cursor.readBufferedDocuments(cursor.bufferedCount()); // Transform the doc if transform method added\n\n        if (cursor.s.transforms && typeof cursor.s.transforms.doc === 'function') {\n          docs = docs.map(cursor.s.transforms.doc);\n        }\n\n        push.apply(items, docs);\n      } // Attempt a fetch\n\n\n      fetchDocs();\n    });\n  };\n\n  fetchDocs();\n}\n\nmodule.exports = {\n  count: count,\n  each: each,\n  hasNext: hasNext,\n  next: next,\n  toArray: toArray\n};","map":null,"metadata":{},"sourceType":"script"}