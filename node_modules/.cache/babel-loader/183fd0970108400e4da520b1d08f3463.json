{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/alexcosta/Desktop/fairflight/node_modules/@babel/runtime/helpers/inherits\");\n\nvar common = require('./common');\n\nvar BulkOperationBase = common.BulkOperationBase;\n\nvar utils = require('../utils');\n\nvar toError = utils.toError;\nvar handleCallback = utils.handleCallback;\nvar BulkWriteResult = common.BulkWriteResult;\nvar Batch = common.Batch;\nvar mergeBatchResults = common.mergeBatchResults;\nvar executeOperation = utils.executeOperation;\n\nvar MongoWriteConcernError = require('mongodb-core').MongoWriteConcernError;\n\nvar handleMongoWriteConcernError = require('./common').handleMongoWriteConcernError;\n\nvar bson = common.bson;\n/**\n * Add to internal list of Operations\n *\n * @param {UnorderedBulkOperation} bulkOperation\n * @param {number} docType number indicating the document type\n * @param {object} document\n * @return {UnorderedBulkOperation}\n */\n\nfunction addToOperationsList(bulkOperation, docType, document) {\n  // Get the bsonSize\n  var bsonSize = bson.calculateObjectSize(document, {\n    checkKeys: false\n  }); // Throw error if the doc is bigger than the max BSON size\n\n  if (bsonSize >= bulkOperation.s.maxBatchSizeBytes) throw toError('document is larger than the maximum size ' + bulkOperation.s.maxBatchSizeBytes); // Holds the current batch\n\n  bulkOperation.s.currentBatch = null; // Get the right type of batch\n\n  if (docType === common.INSERT) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;\n  } else if (docType === common.UPDATE) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;\n  } else if (docType === common.REMOVE) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;\n  } // Create a new batch object if we don't have a current one\n\n\n  if (bulkOperation.s.currentBatch == null) bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex); // Check if we need to create a new batch\n\n  if (bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatch.sizeBytes + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {\n    // Save the batch to the execution stack\n    bulkOperation.s.batches.push(bulkOperation.s.currentBatch); // Create a new batch\n\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);\n  } // We have an array of documents\n\n\n  if (Array.isArray(document)) {\n    throw toError('operation passed in cannot be an Array');\n  } else {\n    bulkOperation.s.currentBatch.operations.push(document);\n    bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);\n    bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;\n  } // Save back the current Batch to the right type\n\n\n  if (docType === common.INSERT) {\n    bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;\n    bulkOperation.s.bulkResult.insertedIds.push({\n      index: bulkOperation.s.bulkResult.insertedIds.length,\n      _id: document._id\n    });\n  } else if (docType === common.UPDATE) {\n    bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;\n  } else if (docType === common.REMOVE) {\n    bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;\n  } // Update current batch size\n\n\n  bulkOperation.s.currentBatch.size = bulkOperation.s.currentBatch.size + 1;\n  bulkOperation.s.currentBatch.sizeBytes = bulkOperation.s.currentBatch.sizeBytes + bsonSize; // Return bulkOperation\n\n  return bulkOperation;\n}\n/**\n * Create a new UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @property {number} length Get the number of operations in the bulk.\n * @return {UnorderedBulkOperation} a UnorderedBulkOperation instance.\n */\n\n\nvar UnorderedBulkOperation =\n/*#__PURE__*/\nfunction (_BulkOperationBase) {\n  _inherits(UnorderedBulkOperation, _BulkOperationBase);\n\n  function UnorderedBulkOperation(topology, collection, options) {\n    _classCallCheck(this, UnorderedBulkOperation);\n\n    options = options || {};\n    options = Object.assign(options, {\n      addToOperationsList: addToOperationsList\n    });\n    return _possibleConstructorReturn(this, _getPrototypeOf(UnorderedBulkOperation).call(this, topology, collection, options, false));\n  }\n  /**\n   * The callback format for results\n   * @callback UnorderedBulkOperation~resultCallback\n   * @param {MongoError} error An error instance representing the error during the execution.\n   * @param {BulkWriteResult} result The bulk write result.\n   */\n\n  /**\n   * Execute the ordered bulk operation\n   *\n   * @method\n   * @param {object} [options] Optional settings.\n   * @param {(number|string)} [options.w] The write concern.\n   * @param {number} [options.wtimeout] The write concern timeout.\n   * @param {boolean} [options.j=false] Specify a journal write concern.\n   * @param {boolean} [options.fsync=false] Specify a file sync write concern.\n   * @param {UnorderedBulkOperation~resultCallback} [callback] The result callback\n   * @throws {MongoError}\n   * @return {Promise} returns Promise if no callback passed\n   */\n\n\n  _createClass(UnorderedBulkOperation, [{\n    key: \"execute\",\n    value: function execute(_writeConcern, options, callback) {\n      var ret = this.bulkExecute(_writeConcern, options, callback);\n      options = ret.options;\n      callback = ret.callback;\n      return executeOperation(this.s.topology, executeBatches, [this, options, callback]);\n    }\n  }]);\n\n  return UnorderedBulkOperation;\n}(BulkOperationBase);\n/**\n * Execute the command\n *\n * @param {UnorderedBulkOperation} bulkOperation\n * @param {object} batch\n * @param {object} options\n * @param {function} callback\n */\n\n\nfunction executeBatch(bulkOperation, batch, options, callback) {\n  function resultHandler(err, result) {\n    // Error is a driver related error not a bulk op error, terminate\n    if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {\n      return handleCallback(callback, err);\n    } // If we have and error\n\n\n    if (err) err.ok = 0;\n\n    if (err instanceof MongoWriteConcernError) {\n      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, false, err, callback);\n    }\n\n    handleCallback(callback, null, mergeBatchResults(false, batch, bulkOperation.s.bulkResult, err, result));\n  }\n\n  bulkOperation.finalOptionsHandler({\n    options: options,\n    batch: batch,\n    resultHandler: resultHandler\n  }, callback);\n}\n/**\n * Execute all the commands\n *\n * @param {UnorderedBulkOperation} bulkOperation\n * @param {object} options\n * @param {function} callback\n */\n\n\nfunction executeBatches(bulkOperation, options, callback) {\n  var numberOfCommandsToExecute = bulkOperation.s.batches.length; // Execute over all the batches\n\n  for (var i = 0; i < bulkOperation.s.batches.length; i++) {\n    executeBatch(bulkOperation, bulkOperation.s.batches[i], options, function (err) {\n      // Count down the number of commands left to execute\n      numberOfCommandsToExecute = numberOfCommandsToExecute - 1; // Execute\n\n      if (numberOfCommandsToExecute === 0) {\n        // Driver level error\n        if (err) return handleCallback(callback, err);\n        var writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);\n        if (bulkOperation.handleWriteError(callback, writeResult)) return;\n        return handleCallback(callback, null, writeResult);\n      }\n    });\n  }\n}\n/**\n * Returns an unordered batch object\n * @ignore\n */\n\n\nfunction initializeUnorderedBulkOp(topology, collection, options) {\n  return new UnorderedBulkOperation(topology, collection, options);\n}\n\ninitializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;\nmodule.exports = initializeUnorderedBulkOp;\nmodule.exports.Bulk = UnorderedBulkOperation;","map":null,"metadata":{},"sourceType":"script"}