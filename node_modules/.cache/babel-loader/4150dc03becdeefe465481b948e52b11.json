{"ast":null,"code":"'use strict';\n\nvar applyWriteConcern = require('../utils').applyWriteConcern;\n\nvar applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nvar checkCollectionName = require('../utils').checkCollectionName;\n\nvar Code = require('mongodb-core').BSON.Code;\n\nvar createIndexDb = require('./db_ops').createIndex;\n\nvar decorateCommand = require('../utils').decorateCommand;\n\nvar decorateWithCollation = require('../utils').decorateWithCollation;\n\nvar decorateWithReadConcern = require('../utils').decorateWithReadConcern;\n\nvar ensureIndexDb = require('./db_ops').ensureIndex;\n\nvar evaluate = require('./db_ops').evaluate;\n\nvar executeCommand = require('./db_ops').executeCommand;\n\nvar executeDbAdminCommand = require('./db_ops').executeDbAdminCommand;\n\nvar formattedOrderClause = require('../utils').formattedOrderClause;\n\nvar resolveReadPreference = require('../utils').resolveReadPreference;\n\nvar handleCallback = require('../utils').handleCallback;\n\nvar indexInformationDb = require('./db_ops').indexInformation;\n\nvar isObject = require('../utils').isObject;\n\nvar Long = require('mongodb-core').BSON.Long;\n\nvar MongoError = require('mongodb-core').MongoError;\n\nvar ReadPreference = require('mongodb-core').ReadPreference;\n\nvar toError = require('../utils').toError;\n/**\n * Group function helper\n * @ignore\n */\n// var groupFunction = function () {\n//   var c = db[ns].find(condition);\n//   var map = new Map();\n//   var reduce_function = reduce;\n//\n//   while (c.hasNext()) {\n//     var obj = c.next();\n//     var key = {};\n//\n//     for (var i = 0, len = keys.length; i < len; ++i) {\n//       var k = keys[i];\n//       key[k] = obj[k];\n//     }\n//\n//     var aggObj = map.get(key);\n//\n//     if (aggObj == null) {\n//       var newObj = Object.extend({}, key);\n//       aggObj = Object.extend(newObj, initial);\n//       map.put(key, aggObj);\n//     }\n//\n//     reduce_function(obj, aggObj);\n//   }\n//\n//   return { \"result\": map.values() };\n// }.toString();\n\n\nvar groupFunction = 'function () {\\nvar c = db[ns].find(condition);\\nvar map = new Map();\\nvar reduce_function = reduce;\\n\\nwhile (c.hasNext()) {\\nvar obj = c.next();\\nvar key = {};\\n\\nfor (var i = 0, len = keys.length; i < len; ++i) {\\nvar k = keys[i];\\nkey[k] = obj[k];\\n}\\n\\nvar aggObj = map.get(key);\\n\\nif (aggObj == null) {\\nvar newObj = Object.extend({}, key);\\naggObj = Object.extend(newObj, initial);\\nmap.put(key, aggObj);\\n}\\n\\nreduce_function(obj, aggObj);\\n}\\n\\nreturn { \"result\": map.values() };\\n}';\n/**\n * Perform a bulkWrite operation. See Collection.prototype.bulkWrite for more information.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object[]} operations Bulk operations to perform.\n * @param {object} [options] Optional settings. See Collection.prototype.bulkWrite for a list of options.\n * @param {Collection~bulkWriteOpCallback} [callback] The command result callback\n */\n\nfunction bulkWrite(coll, operations, options, callback) {\n  // Add ignoreUndfined\n  if (coll.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = coll.s.options.ignoreUndefined;\n  } // Create the bulk operation\n\n\n  var bulk = options.ordered === true || options.ordered == null ? coll.initializeOrderedBulkOp(options) : coll.initializeUnorderedBulkOp(options); // Do we have a collation\n\n  var collation = false; // for each op go through and add to the bulk\n\n  try {\n    for (var i = 0; i < operations.length; i++) {\n      // Get the operation type\n      var key = Object.keys(operations[i])[0]; // Check if we have a collation\n\n      if (operations[i][key].collation) {\n        collation = true;\n      } // Pass to the raw bulk\n\n\n      bulk.raw(operations[i]);\n    }\n  } catch (err) {\n    return callback(err, null);\n  } // Final options for retryable writes and write concern\n\n\n  var finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options);\n  var writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};\n  var capabilities = coll.s.topology.capabilities(); // Did the user pass in a collation, check if our write server supports it\n\n  if (collation && capabilities && !capabilities.commandsTakeCollation) {\n    return callback(new MongoError('server/primary/mongos does not support collation'));\n  } // Execute the bulk\n\n\n  bulk.execute(writeCon, finalOptions, function (err, r) {\n    // We have connection level error\n    if (!r && err) {\n      return callback(err, null);\n    }\n\n    r.insertedCount = r.nInserted;\n    r.matchedCount = r.nMatched;\n    r.modifiedCount = r.nModified || 0;\n    r.deletedCount = r.nRemoved;\n    r.upsertedCount = r.getUpsertedIds().length;\n    r.upsertedIds = {};\n    r.insertedIds = {}; // Update the n\n\n    r.n = r.insertedCount; // Inserted documents\n\n    var inserted = r.getInsertedIds(); // Map inserted ids\n\n    for (var _i = 0; _i < inserted.length; _i++) {\n      r.insertedIds[inserted[_i].index] = inserted[_i]._id;\n    } // Upserted documents\n\n\n    var upserted = r.getUpsertedIds(); // Map upserted ids\n\n    for (var _i2 = 0; _i2 < upserted.length; _i2++) {\n      r.upsertedIds[upserted[_i2].index] = upserted[_i2]._id;\n    } // Return the results\n\n\n    callback(null, r);\n  });\n} // Check the update operation to ensure it has atomic operators.\n\n\nfunction checkForAtomicOperators(update) {\n  var keys = Object.keys(update); // same errors as the server would give for update doc lacking atomic operators\n\n  if (keys.length === 0) {\n    return toError('The update operation document must contain at least one atomic operator.');\n  }\n\n  if (keys[0][0] !== '$') {\n    return toError('the update operation document must contain atomic operators.');\n  }\n}\n/**\n * Count the number of documents in the collection that match the query.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} query The query for the count.\n * @param {object} [options] Optional settings. See Collection.prototype.count for a list of options.\n * @param {Collection~countCallback} [callback] The command result callback\n */\n\n\nfunction count(coll, query, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = Object.assign({}, options);\n  options.collectionName = coll.s.name;\n  options.readPreference = resolveReadPreference(options, {\n    db: coll.s.db,\n    collection: coll\n  });\n  var cmd;\n\n  try {\n    cmd = buildCountCommand(coll, query, options);\n  } catch (err) {\n    return callback(err);\n  }\n\n  executeCommand(coll.s.db, cmd, options, function (err, result) {\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, result.n);\n  });\n}\n\nfunction countDocuments(coll, query, options, callback) {\n  var skip = options.skip;\n  var limit = options.limit;\n  options = Object.assign({}, options);\n  var pipeline = [{\n    $match: query\n  }]; // Add skip and limit if defined\n\n  if (typeof skip === 'number') {\n    pipeline.push({\n      $skip: skip\n    });\n  }\n\n  if (typeof limit === 'number') {\n    pipeline.push({\n      $limit: limit\n    });\n  }\n\n  pipeline.push({\n    $group: {\n      _id: null,\n      n: {\n        $sum: 1\n      }\n    }\n  });\n  delete options.limit;\n  delete options.skip;\n  coll.aggregate(pipeline, options).toArray(function (err, docs) {\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, docs.length ? docs[0].n : 0);\n  });\n}\n/**\n * Build the count command.\n *\n * @method\n * @param {collectionOrCursor} an instance of a collection or cursor\n * @param {object} query The query for the count.\n * @param {object} [options] Optional settings. See Collection.prototype.count and Cursor.prototype.count for a list of options.\n */\n\n\nfunction buildCountCommand(collectionOrCursor, query, options) {\n  var skip = options.skip;\n  var limit = options.limit;\n  var hint = options.hint;\n  var maxTimeMS = options.maxTimeMS;\n  query = query || {}; // Final query\n\n  var cmd = {\n    count: options.collectionName,\n    query: query\n  }; // check if collectionOrCursor is a cursor by using cursor.s.numberOfRetries\n\n  if (collectionOrCursor.s.numberOfRetries) {\n    if (collectionOrCursor.s.options.hint) {\n      hint = collectionOrCursor.s.options.hint;\n    } else if (collectionOrCursor.s.cmd.hint) {\n      hint = collectionOrCursor.s.cmd.hint;\n    }\n\n    decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.s.cmd);\n  } else {\n    decorateWithCollation(cmd, collectionOrCursor, options);\n  } // Add limit, skip and maxTimeMS if defined\n\n\n  if (typeof skip === 'number') cmd.skip = skip;\n  if (typeof limit === 'number') cmd.limit = limit;\n  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;\n  if (hint) cmd.hint = hint; // Do we have a readConcern specified\n\n  decorateWithReadConcern(cmd, collectionOrCursor);\n  return cmd;\n}\n/**\n * Create an index on the db and collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Collection.prototype.createIndex for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction createIndex(coll, fieldOrSpec, options, callback) {\n  createIndexDb(coll.s.db, coll.s.name, fieldOrSpec, options, callback);\n}\n/**\n * Create multiple indexes in the collection. This method is only supported for\n * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {array} indexSpecs An array of index specifications to be created\n * @param {Object} [options] Optional settings. See Collection.prototype.createIndexes for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction createIndexes(coll, indexSpecs, options, callback) {\n  var capabilities = coll.s.topology.capabilities(); // Ensure we generate the correct name if the parameter is not set\n\n  for (var i = 0; i < indexSpecs.length; i++) {\n    if (indexSpecs[i].name == null) {\n      var keys = []; // Did the user pass in a collation, check if our write server supports it\n\n      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {\n        return callback(new MongoError('server/primary/mongos does not support collation'));\n      }\n\n      for (var name in indexSpecs[i].key) {\n        keys.push(\"\".concat(name, \"_\").concat(indexSpecs[i].key[name]));\n      } // Set the name\n\n\n      indexSpecs[i].name = keys.join('_');\n    }\n  }\n\n  options = Object.assign({}, options, {\n    readPreference: ReadPreference.PRIMARY\n  }); // Execute the index\n\n  executeCommand(coll.s.db, {\n    createIndexes: coll.s.name,\n    indexes: indexSpecs\n  }, options, callback);\n}\n\nfunction deleteCallback(err, r, callback) {\n  if (callback == null) return;\n  if (err && callback) return callback(err);\n  if (r == null) return callback(null, {\n    result: {\n      ok: 1\n    }\n  });\n  r.deletedCount = r.result.n;\n  if (callback) callback(null, r);\n}\n/**\n * Delete multiple documents from the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} filter The Filter used to select the documents to remove\n * @param {object} [options] Optional settings. See Collection.prototype.deleteMany for a list of options.\n * @param {Collection~deleteWriteOpCallback} [callback] The command result callback\n */\n\n\nfunction deleteMany(coll, filter, options, callback) {\n  options.single = false;\n  removeDocuments(coll, filter, options, function (err, r) {\n    return deleteCallback(err, r, callback);\n  });\n}\n/**\n * Delete a single document from the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} filter The Filter used to select the document to remove\n * @param {object} [options] Optional settings. See Collection.prototype.deleteOne for a list of options.\n * @param {Collection~deleteWriteOpCallback} [callback] The command result callback\n */\n\n\nfunction deleteOne(coll, filter, options, callback) {\n  options.single = true;\n  removeDocuments(coll, filter, options, function (err, r) {\n    return deleteCallback(err, r, callback);\n  });\n}\n/**\n * Return a list of distinct values for the given key across a collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {string} key Field of the document to find distinct values for.\n * @param {object} query The query for filtering the set of documents to which we apply the distinct filter.\n * @param {object} [options] Optional settings. See Collection.prototype.distinct for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction distinct(coll, key, query, options, callback) {\n  // maxTimeMS option\n  var maxTimeMS = options.maxTimeMS; // Distinct command\n\n  var cmd = {\n    distinct: coll.s.name,\n    key: key,\n    query: query\n  };\n  options = Object.assign({}, options); // Ensure we have the right read preference inheritance\n\n  options.readPreference = resolveReadPreference(options, {\n    db: coll.s.db,\n    collection: coll\n  }); // Add maxTimeMS if defined\n\n  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS; // Do we have a readConcern specified\n\n  decorateWithReadConcern(cmd, coll, options); // Have we specified collation\n\n  try {\n    decorateWithCollation(cmd, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  } // Execute the command\n\n\n  executeCommand(coll.s.db, cmd, options, function (err, result) {\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, result.values);\n  });\n}\n/**\n * Drop an index from this collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {string} indexName Name of the index to drop.\n * @param {object} [options] Optional settings. See Collection.prototype.dropIndex for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction dropIndex(coll, indexName, options, callback) {\n  // Delete index command\n  var cmd = {\n    dropIndexes: coll.s.name,\n    index: indexName\n  }; // Decorate command with writeConcern if supported\n\n  applyWriteConcern(cmd, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Execute command\n\n  executeCommand(coll.s.db, cmd, options, function (err, result) {\n    if (typeof callback !== 'function') return;\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result);\n  });\n}\n/**\n * Drop all indexes from this collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {Object} [options] Optional settings. See Collection.prototype.dropIndexes for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction dropIndexes(coll, options, callback) {\n  dropIndex(coll, '*', options, function (err) {\n    if (err) return handleCallback(callback, err, false);\n    handleCallback(callback, null, true);\n  });\n}\n/**\n * Ensure that an index exists. If the index does not exist, this function creates it.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Collection.prototype.ensureIndex for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction ensureIndex(coll, fieldOrSpec, options, callback) {\n  ensureIndexDb(coll.s.db, coll.s.name, fieldOrSpec, options, callback);\n}\n/**\n * Find and update a document.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} doc The fields/vals to be updated.\n * @param {object} [options] Optional settings. See Collection.prototype.findAndModify for a list of options.\n * @param {Collection~findAndModifyCallback} [callback] The command result callback\n * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead\n */\n\n\nfunction findAndModify(coll, query, sort, doc, options, callback) {\n  // Create findAndModify command object\n  var queryObject = {\n    findAndModify: coll.s.name,\n    query: query\n  };\n  sort = formattedOrderClause(sort);\n\n  if (sort) {\n    queryObject.sort = sort;\n  }\n\n  queryObject.new = options.new ? true : false;\n  queryObject.remove = options.remove ? true : false;\n  queryObject.upsert = options.upsert ? true : false;\n  var projection = options.projection || options.fields;\n\n  if (projection) {\n    queryObject.fields = projection;\n  }\n\n  if (options.arrayFilters) {\n    queryObject.arrayFilters = options.arrayFilters;\n    delete options.arrayFilters;\n  }\n\n  if (doc && !options.remove) {\n    queryObject.update = doc;\n  }\n\n  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS; // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // No check on the documents\n\n  options.checkKeys = false; // Final options for retryable writes and write concern\n\n  var finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Decorate the findAndModify command with the write Concern\n\n  if (finalOptions.writeConcern) {\n    queryObject.writeConcern = finalOptions.writeConcern;\n  } // Have we specified bypassDocumentValidation\n\n\n  if (finalOptions.bypassDocumentValidation === true) {\n    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;\n  }\n\n  finalOptions.readPreference = ReadPreference.primary; // Have we specified collation\n\n  try {\n    decorateWithCollation(queryObject, coll, finalOptions);\n  } catch (err) {\n    return callback(err, null);\n  } // Execute the command\n\n\n  executeCommand(coll.s.db, queryObject, finalOptions, function (err, result) {\n    if (err) return handleCallback(callback, err, null);\n    return handleCallback(callback, null, result);\n  });\n}\n/**\n * Find and remove a document.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} [options] Optional settings. See Collection.prototype.findAndRemove for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @deprecated use findOneAndDelete instead\n */\n\n\nfunction findAndRemove(coll, query, sort, options, callback) {\n  // Add the remove option\n  options.remove = true; // Execute the callback\n\n  findAndModify(coll, query, sort, null, options, callback);\n}\n/**\n * Fetch the first document that matches the query.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} query Query for find Operation\n * @param {object} [options] Optional settings. See Collection.prototype.findOne for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction findOne(coll, query, options, callback) {\n  var cursor = coll.find(query, options).limit(-1).batchSize(1); // Return the item\n\n  cursor.next(function (err, item) {\n    if (err != null) return handleCallback(callback, toError(err), null);\n    handleCallback(callback, null, item);\n  });\n}\n/**\n * Find a document and delete it in one atomic operation. This requires a write lock for the duration of the operation.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} filter Document selection filter.\n * @param {object} [options] Optional settings. See Collection.prototype.findOneAndDelete for a list of options.\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n */\n\n\nfunction findOneAndDelete(coll, filter, options, callback) {\n  // Final options\n  var finalOptions = Object.assign({}, options);\n  finalOptions.fields = options.projection;\n  finalOptions.remove = true; // Execute find and Modify\n\n  findAndModify(coll, filter, options.sort, null, finalOptions, callback);\n}\n/**\n * Find a document and replace it in one atomic operation. This requires a write lock for the duration of the operation.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} filter Document selection filter.\n * @param {object} replacement Document replacing the matching document.\n * @param {object} [options] Optional settings. See Collection.prototype.findOneAndReplace for a list of options.\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n */\n\n\nfunction findOneAndReplace(coll, filter, replacement, options, callback) {\n  // Final options\n  var finalOptions = Object.assign({}, options);\n  finalOptions.fields = options.projection;\n  finalOptions.update = true;\n  finalOptions.new = options.returnOriginal !== void 0 ? !options.returnOriginal : false;\n  finalOptions.upsert = options.upsert !== void 0 ? !!options.upsert : false; // Execute findAndModify\n\n  findAndModify(coll, filter, options.sort, replacement, finalOptions, callback);\n}\n/**\n * Find a document and update it in one atomic operation. This requires a write lock for the duration of the operation.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} filter Document selection filter.\n * @param {object} update Update operations to be performed on the document\n * @param {object} [options] Optional settings. See Collection.prototype.findOneAndUpdate for a list of options.\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n */\n\n\nfunction findOneAndUpdate(coll, filter, update, options, callback) {\n  // Final options\n  var finalOptions = Object.assign({}, options);\n  finalOptions.fields = options.projection;\n  finalOptions.update = true;\n  finalOptions.new = typeof options.returnOriginal === 'boolean' ? !options.returnOriginal : false;\n  finalOptions.upsert = typeof options.upsert === 'boolean' ? options.upsert : false; // Execute findAndModify\n\n  findAndModify(coll, filter, options.sort, update, finalOptions, callback);\n}\n/**\n * Execute a geo search using a geo haystack index on a collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.\n * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.\n * @param {object} [options] Optional settings. See Collection.prototype.geoHaystackSearch for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction geoHaystackSearch(coll, x, y, options, callback) {\n  // Build command object\n  var commandObject = {\n    geoSearch: coll.s.name,\n    near: [x, y]\n  }; // Remove read preference from hash if it exists\n\n  commandObject = decorateCommand(commandObject, options, ['readPreference', 'session']);\n  options = Object.assign({}, options); // Ensure we have the right read preference inheritance\n\n  options.readPreference = resolveReadPreference(options, {\n    db: coll.s.db,\n    collection: coll\n  }); // Do we have a readConcern specified\n\n  decorateWithReadConcern(commandObject, coll, options); // Execute the command\n\n  executeCommand(coll.s.db, commandObject, options, function (err, res) {\n    if (err) return handleCallback(callback, err);\n    if (res.err || res.errmsg) handleCallback(callback, toError(res)); // should we only be returning res.results here? Not sure if the user\n    // should see the other return information\n\n    handleCallback(callback, null, res);\n  });\n}\n/**\n * Run a group command across a collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.\n * @param {object} condition An optional condition that must be true for a row to be considered.\n * @param {object} initial Initial value of the aggregation counter object.\n * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated\n * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.\n * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.\n * @param {object} [options] Optional settings. See Collection.prototype.group for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @deprecated MongoDB 3.6 or higher will no longer support the group command. We recommend rewriting using the aggregation framework.\n */\n\n\nfunction group(coll, keys, condition, initial, reduce, finalize, command, options, callback) {\n  // Execute using the command\n  if (command) {\n    var reduceFunction = reduce && reduce._bsontype === 'Code' ? reduce : new Code(reduce);\n    var selector = {\n      group: {\n        ns: coll.s.name,\n        $reduce: reduceFunction,\n        cond: condition,\n        initial: initial,\n        out: 'inline'\n      }\n    }; // if finalize is defined\n\n    if (finalize != null) selector.group['finalize'] = finalize; // Set up group selector\n\n    if ('function' === typeof keys || keys && keys._bsontype === 'Code') {\n      selector.group.$keyf = keys && keys._bsontype === 'Code' ? keys : new Code(keys);\n    } else {\n      var hash = {};\n      keys.forEach(function (key) {\n        hash[key] = 1;\n      });\n      selector.group.key = hash;\n    }\n\n    options = Object.assign({}, options); // Ensure we have the right read preference inheritance\n\n    options.readPreference = resolveReadPreference(options, {\n      db: coll.s.db,\n      collection: coll\n    }); // Do we have a readConcern specified\n\n    decorateWithReadConcern(selector, coll, options); // Have we specified collation\n\n    try {\n      decorateWithCollation(selector, coll, options);\n    } catch (err) {\n      return callback(err, null);\n    } // Execute command\n\n\n    executeCommand(coll.s.db, selector, options, function (err, result) {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, result.retval);\n    });\n  } else {\n    // Create execution scope\n    var scope = reduce != null && reduce._bsontype === 'Code' ? reduce.scope : {};\n    scope.ns = coll.s.name;\n    scope.keys = keys;\n    scope.condition = condition;\n    scope.initial = initial; // Pass in the function text to execute within mongodb.\n\n    var groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');\n    evaluate(coll.s.db, new Code(groupfn, scope), null, options, function (err, results) {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, results.result || results);\n    });\n  }\n}\n/**\n * Retrieve all the indexes on the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {Object} [options] Optional settings. See Collection.prototype.indexes for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexes(coll, options, callback) {\n  options = Object.assign({}, {\n    full: true\n  }, options);\n  indexInformationDb(coll.s.db, coll.s.name, options, callback);\n}\n/**\n * Check if one or more indexes exist on the collection. This fails on the first index that doesn't exist.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(string|array)} indexes One or more index names to check.\n * @param {Object} [options] Optional settings. See Collection.prototype.indexExists for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexExists(coll, indexes, options, callback) {\n  indexInformation(coll, options, function (err, indexInformation) {\n    // If we have an error return\n    if (err != null) return handleCallback(callback, err, null); // Let's check for the index names\n\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, indexInformation[indexes] != null); // Check in list of indexes\n\n    for (var i = 0; i < indexes.length; i++) {\n      if (indexInformation[indexes[i]] == null) {\n        return handleCallback(callback, null, false);\n      }\n    } // All keys found return true\n\n\n    return handleCallback(callback, null, true);\n  });\n}\n/**\n * Retrieve this collection's index info.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} [options] Optional settings. See Collection.prototype.indexInformation for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexInformation(coll, options, callback) {\n  indexInformationDb(coll.s.db, coll.s.name, options, callback);\n}\n\nfunction insertDocuments(coll, docs, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Ensure we are operating on an array op docs\n\n  docs = Array.isArray(docs) ? docs : [docs]; // Final options for retryable writes and write concern\n\n  var finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // If keep going set unordered\n\n  if (finalOptions.keepGoing === true) finalOptions.ordered = false;\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n  docs = prepareDocs(coll, docs, options); // File inserts\n\n  coll.s.topology.insert(coll.s.namespace, docs, finalOptions, function (err, result) {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Add docs to the list\n\n    result.ops = docs; // Return the results\n\n    handleCallback(callback, null, result);\n  });\n}\n/**\n * Insert a single document into the collection. See Collection.prototype.insertOne for more information.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} doc Document to insert.\n * @param {object} [options] Optional settings. See Collection.prototype.insertOne for a list of options.\n * @param {Collection~insertOneWriteOpCallback} [callback] The command result callback\n */\n\n\nfunction insertOne(coll, doc, options, callback) {\n  if (Array.isArray(doc)) {\n    return callback(MongoError.create({\n      message: 'doc parameter must be an object',\n      driver: true\n    }));\n  }\n\n  insertDocuments(coll, [doc], options, function (err, r) {\n    if (callback == null) return;\n    if (err && callback) return callback(err); // Workaround for pre 2.6 servers\n\n    if (r == null) return callback(null, {\n      result: {\n        ok: 1\n      }\n    }); // Add values to top level to ensure crud spec compatibility\n\n    r.insertedCount = r.result.n;\n    r.insertedId = doc._id;\n    if (callback) callback(null, r);\n  });\n}\n/**\n * Determine whether the collection is a capped collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {Object} [options] Optional settings. See Collection.prototype.isCapped for a list of options.\n * @param {Collection~resultCallback} [callback] The results callback\n */\n\n\nfunction isCapped(coll, options, callback) {\n  optionsOp(coll, options, function (err, document) {\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, !!(document && document.capped));\n  });\n}\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {(function|string)} map The mapping function.\n * @param {(function|string)} reduce The reduce function.\n * @param {object} [options] Optional settings. See Collection.prototype.mapReduce for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction mapReduce(coll, map, reduce, options, callback) {\n  var mapCommandHash = {\n    mapreduce: coll.s.name,\n    map: map,\n    reduce: reduce\n  }; // Exclusion list\n\n  var exclusionList = ['readPreference', 'session', 'bypassDocumentValidation']; // Add any other options passed in\n\n  for (var n in options) {\n    if ('scope' === n) {\n      mapCommandHash[n] = processScope(options[n]);\n    } else {\n      // Only include if not in exclusion list\n      if (exclusionList.indexOf(n) === -1) {\n        mapCommandHash[n] = options[n];\n      }\n    }\n  }\n\n  options = Object.assign({}, options); // Ensure we have the right read preference inheritance\n\n  options.readPreference = resolveReadPreference(options, {\n    db: coll.s.db,\n    collection: coll\n  }); // If we have a read preference and inline is not set as output fail hard\n\n  if (options.readPreference !== false && options.readPreference !== 'primary' && options['out'] && options['out'].inline !== 1 && options['out'] !== 'inline') {\n    // Force readPreference to primary\n    options.readPreference = 'primary'; // Decorate command with writeConcern if supported\n\n    applyWriteConcern(mapCommandHash, {\n      db: coll.s.db,\n      collection: coll\n    }, options);\n  } else {\n    decorateWithReadConcern(mapCommandHash, coll, options);\n  } // Is bypassDocumentValidation specified\n\n\n  if (options.bypassDocumentValidation === true) {\n    mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n  } // Have we specified collation\n\n\n  try {\n    decorateWithCollation(mapCommandHash, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  } // Execute command\n\n\n  executeCommand(coll.s.db, mapCommandHash, options, function (err, result) {\n    if (err) return handleCallback(callback, err); // Check if we have an error\n\n    if (1 !== result.ok || result.err || result.errmsg) {\n      return handleCallback(callback, toError(result));\n    } // Create statistics value\n\n\n    var stats = {};\n    if (result.timeMillis) stats['processtime'] = result.timeMillis;\n    if (result.counts) stats['counts'] = result.counts;\n    if (result.timing) stats['timing'] = result.timing; // invoked with inline?\n\n    if (result.results) {\n      // If we wish for no verbosity\n      if (options['verbose'] == null || !options['verbose']) {\n        return handleCallback(callback, null, result.results);\n      }\n\n      return handleCallback(callback, null, {\n        results: result.results,\n        stats: stats\n      });\n    } // The returned collection\n\n\n    var collection = null; // If we have an object it's a different db\n\n    if (result.result != null && typeof result.result === 'object') {\n      var doc = result.result; // Return a collection from another db\n\n      var Db = require('../db');\n\n      collection = new Db(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(doc.collection);\n    } else {\n      // Create a collection object that wraps the result collection\n      collection = coll.s.db.collection(result.result);\n    } // If we wish for no verbosity\n\n\n    if (options['verbose'] == null || !options['verbose']) {\n      return handleCallback(callback, err, collection);\n    } // Return stats as third set of values\n\n\n    handleCallback(callback, err, {\n      collection: collection,\n      stats: stats\n    });\n  });\n}\n/**\n * Return the options of the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {Object} [options] Optional settings. See Collection.prototype.options for a list of options.\n * @param {Collection~resultCallback} [callback] The results callback\n */\n\n\nfunction optionsOp(coll, opts, callback) {\n  coll.s.db.listCollections({\n    name: coll.s.name\n  }, opts).toArray(function (err, collections) {\n    if (err) return handleCallback(callback, err);\n\n    if (collections.length === 0) {\n      return handleCallback(callback, MongoError.create({\n        message: \"collection \".concat(coll.s.namespace, \" not found\"),\n        driver: true\n      }));\n    }\n\n    handleCallback(callback, err, collections[0].options || null);\n  });\n}\n/**\n * Return N parallel cursors for a collection to allow parallel reading of the entire collection. There are\n * no ordering guarantees for returned results.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} [options] Optional settings. See Collection.prototype.parallelCollectionScan for a list of options.\n * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback\n */\n\n\nfunction parallelCollectionScan(coll, options, callback) {\n  // Create command object\n  var commandObject = {\n    parallelCollectionScan: coll.s.name,\n    numCursors: options.numCursors\n  }; // Do we have a readConcern specified\n\n  decorateWithReadConcern(commandObject, coll, options); // Store the raw value\n\n  var raw = options.raw;\n  delete options['raw']; // Execute the command\n\n  executeCommand(coll.s.db, commandObject, options, function (err, result) {\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, new Error('no result returned for parallelCollectionScan'), null);\n    options = Object.assign({\n      explicitlyIgnoreSession: true\n    }, options);\n    var cursors = []; // Add the raw back to the option\n\n    if (raw) options.raw = raw; // Create command cursors for each item\n\n    for (var i = 0; i < result.cursors.length; i++) {\n      var rawId = result.cursors[i].cursor.id; // Convert cursorId to Long if needed\n\n      var cursorId = typeof rawId === 'number' ? Long.fromNumber(rawId) : rawId; // Add a command cursor\n\n      cursors.push(coll.s.topology.cursor(coll.s.namespace, cursorId, options));\n    }\n\n    handleCallback(callback, null, cursors);\n  });\n} // modifies documents before being inserted or updated\n\n\nfunction prepareDocs(coll, docs, options) {\n  var forceServerObjectId = typeof options.forceServerObjectId === 'boolean' ? options.forceServerObjectId : coll.s.db.options.forceServerObjectId; // no need to modify the docs if server sets the ObjectId\n\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n\n  return docs.map(function (doc) {\n    if (forceServerObjectId !== true && doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  });\n}\n/**\n * Functions that are passed as scope args must\n * be converted to Code instances.\n * @ignore\n */\n\n\nfunction processScope(scope) {\n  if (!isObject(scope) || scope._bsontype === 'ObjectID') {\n    return scope;\n  }\n\n  var keys = Object.keys(scope);\n  var key;\n  var new_scope = {};\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    key = keys[i];\n\n    if ('function' === typeof scope[key]) {\n      new_scope[key] = new Code(String(scope[key]));\n    } else {\n      new_scope[key] = processScope(scope[key]);\n    }\n  }\n\n  return new_scope;\n}\n/**\n * Reindex all indexes on the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {Object} [options] Optional settings. See Collection.prototype.reIndex for a list of options.\n * @param {Collection~resultCallback} [callback] The command result callback\n */\n\n\nfunction reIndex(coll, options, callback) {\n  // Reindex\n  var cmd = {\n    reIndex: coll.s.name\n  }; // Execute the command\n\n  executeCommand(coll.s.db, cmd, options, function (err, result) {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result.ok ? true : false);\n  });\n}\n\nfunction removeDocuments(coll, selector, options, callback) {\n  if (typeof options === 'function') {\n    callback = options, options = {};\n  } else if (typeof selector === 'function') {\n    callback = selector;\n    options = {};\n    selector = {};\n  } // Create an empty options object if the provided one is null\n\n\n  options = options || {}; // Final options for retryable writes and write concern\n\n  var finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // If selector is null set empty\n\n  if (selector == null) selector = {}; // Build the op\n\n  var op = {\n    q: selector,\n    limit: 0\n  };\n\n  if (options.single) {\n    op.limit = 1;\n  } else if (finalOptions.retryWrites) {\n    finalOptions.retryWrites = false;\n  } // Have we specified collation\n\n\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  } // Execute the remove\n\n\n  coll.s.topology.remove(coll.s.namespace, [op], finalOptions, function (err, result) {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Return the results\n\n    handleCallback(callback, null, result);\n  });\n}\n/**\n * Rename the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {string} newName New name of of the collection.\n * @param {object} [options] Optional settings. See Collection.prototype.rename for a list of options.\n * @param {Collection~collectionResultCallback} [callback] The results callback\n */\n\n\nfunction rename(coll, newName, options, callback) {\n  var Collection = require('../collection'); // Check the collection name\n\n\n  checkCollectionName(newName); // Build the command\n\n  var renameCollection = \"\".concat(coll.s.dbName, \".\").concat(coll.s.name);\n  var toCollection = \"\".concat(coll.s.dbName, \".\").concat(newName);\n  var dropTarget = typeof options.dropTarget === 'boolean' ? options.dropTarget : false;\n  var cmd = {\n    renameCollection: renameCollection,\n    to: toCollection,\n    dropTarget: dropTarget\n  }; // Decorate command with writeConcern if supported\n\n  applyWriteConcern(cmd, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Execute against admin\n\n  executeDbAdminCommand(coll.s.db.admin().s.db, cmd, options, function (err, doc) {\n    if (err) return handleCallback(callback, err, null); // We have an error\n\n    if (doc.errmsg) return handleCallback(callback, toError(doc), null);\n\n    try {\n      return handleCallback(callback, null, new Collection(coll.s.db, coll.s.topology, coll.s.dbName, newName, coll.s.pkFactory, coll.s.options));\n    } catch (err) {\n      return handleCallback(callback, toError(err), null);\n    }\n  });\n}\n/**\n * Replace a document in the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} filter The Filter used to select the document to update\n * @param {object} doc The Document that replaces the matching document\n * @param {object} [options] Optional settings. See Collection.prototype.replaceOne for a list of options.\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n */\n\n\nfunction replaceOne(coll, filter, doc, options, callback) {\n  // Set single document update\n  options.multi = false; // Execute update\n\n  updateDocuments(coll, filter, doc, options, function (err, r) {\n    if (callback == null) return;\n    if (err && callback) return callback(err);\n    if (r == null) return callback(null, {\n      result: {\n        ok: 1\n      }\n    });\n    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;\n    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] // FIXME(major): should be `r.result.upserted[0]._id`\n    : null;\n    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;\n    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;\n    r.ops = [doc];\n    if (callback) callback(null, r);\n  });\n}\n/**\n * Save a document.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} doc Document to save\n * @param {object} [options] Optional settings. See Collection.prototype.save for a list of options.\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @deprecated use insertOne, insertMany, updateOne or updateMany\n */\n\n\nfunction save(coll, doc, options, callback) {\n  // Get the write concern options\n  var finalOptions = applyWriteConcern(Object.assign({}, options), {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Establish if we need to perform an insert or update\n\n  if (doc._id != null) {\n    finalOptions.upsert = true;\n    return updateDocuments(coll, {\n      _id: doc._id\n    }, doc, finalOptions, callback);\n  } // Insert the document\n\n\n  insertDocuments(coll, [doc], finalOptions, function (err, result) {\n    if (callback == null) return;\n    if (doc == null) return handleCallback(callback, null, null);\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result);\n  });\n}\n/**\n * Get all the collection statistics.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} [options] Optional settings. See Collection.prototype.stats for a list of options.\n * @param {Collection~resultCallback} [callback] The collection result callback\n */\n\n\nfunction stats(coll, options, callback) {\n  // Build command object\n  var commandObject = {\n    collStats: coll.s.name\n  }; // Check if we have the scale value\n\n  if (options['scale'] != null) commandObject['scale'] = options['scale'];\n  options = Object.assign({}, options); // Ensure we have the right read preference inheritance\n\n  options.readPreference = resolveReadPreference(options, {\n    db: coll.s.db,\n    collection: coll\n  }); // Execute the command\n\n  executeCommand(coll.s.db, commandObject, options, callback);\n}\n\nfunction updateCallback(err, r, callback) {\n  if (callback == null) return;\n  if (err) return callback(err);\n  if (r == null) return callback(null, {\n    result: {\n      ok: 1\n    }\n  });\n  r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;\n  r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] // FIXME(major): should be `r.result.upserted[0]._id`\n  : null;\n  r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;\n  r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;\n  callback(null, r);\n}\n\nfunction updateDocuments(coll, selector, document, options, callback) {\n  if ('function' === typeof options) callback = options, options = null;\n  if (options == null) options = {};\n  if (!('function' === typeof callback)) callback = null; // If we are not providing a selector or document throw\n\n  if (selector == null || typeof selector !== 'object') return callback(toError('selector must be a valid JavaScript object'));\n  if (document == null || typeof document !== 'object') return callback(toError('document must be a valid JavaScript object')); // Final options for retryable writes and write concern\n\n  var finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Do we return the actual result document\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // Execute the operation\n\n  var op = {\n    q: selector,\n    u: document\n  };\n  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;\n  op.multi = options.multi !== void 0 ? !!options.multi : false;\n\n  if (finalOptions.arrayFilters) {\n    op.arrayFilters = finalOptions.arrayFilters;\n    delete finalOptions.arrayFilters;\n  }\n\n  if (finalOptions.retryWrites && op.multi) {\n    finalOptions.retryWrites = false;\n  } // Have we specified collation\n\n\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  } // Update options\n\n\n  coll.s.topology.update(coll.s.namespace, [op], finalOptions, function (err, result) {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Return the results\n\n    handleCallback(callback, null, result);\n  });\n}\n/**\n * Update multiple documents in the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} filter The Filter used to select the documents to update\n * @param {object} update The update operations to be applied to the document\n * @param {object} [options] Optional settings. See Collection.prototype.updateMany for a list of options.\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n */\n\n\nfunction updateMany(coll, filter, update, options, callback) {\n  // Set single document update\n  options.multi = true; // Execute update\n\n  updateDocuments(coll, filter, update, options, function (err, r) {\n    return updateCallback(err, r, callback);\n  });\n}\n/**\n * Update a single document in the collection.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} filter The Filter used to select the document to update\n * @param {object} update The update operations to be applied to the document\n * @param {object} [options] Optional settings. See Collection.prototype.updateOne for a list of options.\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n */\n\n\nfunction updateOne(coll, filter, update, options, callback) {\n  // Set single document update\n  options.multi = false; // Execute update\n\n  updateDocuments(coll, filter, update, options, function (err, r) {\n    return updateCallback(err, r, callback);\n  });\n}\n\nmodule.exports = {\n  bulkWrite: bulkWrite,\n  checkForAtomicOperators: checkForAtomicOperators,\n  count: count,\n  countDocuments: countDocuments,\n  buildCountCommand: buildCountCommand,\n  createIndex: createIndex,\n  createIndexes: createIndexes,\n  deleteMany: deleteMany,\n  deleteOne: deleteOne,\n  distinct: distinct,\n  dropIndex: dropIndex,\n  dropIndexes: dropIndexes,\n  ensureIndex: ensureIndex,\n  findAndModify: findAndModify,\n  findAndRemove: findAndRemove,\n  findOne: findOne,\n  findOneAndDelete: findOneAndDelete,\n  findOneAndReplace: findOneAndReplace,\n  findOneAndUpdate: findOneAndUpdate,\n  geoHaystackSearch: geoHaystackSearch,\n  group: group,\n  indexes: indexes,\n  indexExists: indexExists,\n  indexInformation: indexInformation,\n  insertOne: insertOne,\n  isCapped: isCapped,\n  mapReduce: mapReduce,\n  optionsOp: optionsOp,\n  parallelCollectionScan: parallelCollectionScan,\n  prepareDocs: prepareDocs,\n  reIndex: reIndex,\n  removeDocuments: removeDocuments,\n  rename: rename,\n  replaceOne: replaceOne,\n  save: save,\n  stats: stats,\n  updateDocuments: updateDocuments,\n  updateMany: updateMany,\n  updateOne: updateOne\n};","map":null,"metadata":{},"sourceType":"script"}