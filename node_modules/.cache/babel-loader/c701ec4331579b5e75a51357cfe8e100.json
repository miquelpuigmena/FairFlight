{"ast":null,"code":"'use strict';\n\nvar authenticate = require('../authenticate');\n\nvar deprecate = require('util').deprecate;\n\nvar Logger = require('mongodb-core').Logger;\n\nvar MongoError = require('mongodb-core').MongoError;\n\nvar Mongos = require('../topologies/mongos');\n\nvar parse = require('mongodb-core').parseConnectionString;\n\nvar ReadPreference = require('mongodb-core').ReadPreference;\n\nvar ReplSet = require('../topologies/replset');\n\nvar Server = require('../topologies/server');\n\nvar ServerSessionPool = require('mongodb-core').Sessions.ServerSessionPool;\n\nvar monitoringEvents = ['timeout', 'close', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'commandStarted', 'commandSucceeded', 'commandFailed', 'joined', 'left', 'ping', 'ha', 'all', 'fullsetup', 'open'];\nvar ignoreOptionNames = ['native_parser'];\nvar legacyOptionNames = ['server', 'replset', 'replSet', 'mongos', 'db'];\nvar legacyParse = deprecate(require('../url_parser'), 'current URL string parser is deprecated, and will be removed in a future version. ' + 'To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.');\nvar validOptionNames = ['poolSize', 'ssl', 'sslValidate', 'sslCA', 'sslCert', 'sslKey', 'sslPass', 'sslCRL', 'autoReconnect', 'noDelay', 'keepAlive', 'keepAliveInitialDelay', 'connectTimeoutMS', 'family', 'socketTimeoutMS', 'reconnectTries', 'reconnectInterval', 'ha', 'haInterval', 'replicaSet', 'secondaryAcceptableLatencyMS', 'acceptableLatencyMS', 'connectWithNoPrimary', 'authSource', 'w', 'wtimeout', 'j', 'forceServerObjectId', 'serializeFunctions', 'ignoreUndefined', 'raw', 'bufferMaxEntries', 'readPreference', 'pkFactory', 'promiseLibrary', 'readConcern', 'maxStalenessSeconds', 'loggerLevel', 'logger', 'promoteValues', 'promoteBuffers', 'promoteLongs', 'domainsEnabled', 'checkServerIdentity', 'validateOptions', 'appname', 'auth', 'user', 'password', 'authMechanism', 'compression', 'fsync', 'readPreferenceTags', 'numberOfRetries', 'auto_reconnect', 'minSize', 'monitorCommands', 'retryWrites', 'useNewUrlParser'];\n\nfunction addListeners(mongoClient, topology) {\n  topology.on('authenticated', createListener(mongoClient, 'authenticated'));\n  topology.on('error', createListener(mongoClient, 'error'));\n  topology.on('timeout', createListener(mongoClient, 'timeout'));\n  topology.on('close', createListener(mongoClient, 'close'));\n  topology.on('parseError', createListener(mongoClient, 'parseError'));\n  topology.once('open', createListener(mongoClient, 'open'));\n  topology.once('fullsetup', createListener(mongoClient, 'fullsetup'));\n  topology.once('all', createListener(mongoClient, 'all'));\n  topology.on('reconnect', createListener(mongoClient, 'reconnect'));\n}\n\nfunction assignTopology(client, topology) {\n  client.topology = topology;\n  topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);\n} // Clear out all events\n\n\nfunction clearAllEvents(topology) {\n  monitoringEvents.forEach(function (event) {\n    return topology.removeAllListeners(event);\n  });\n} // Collect all events in order from SDAM\n\n\nfunction collectEvents(mongoClient, topology) {\n  var MongoClient = require('../mongo_client');\n\n  var collectedEvents = [];\n\n  if (mongoClient instanceof MongoClient) {\n    monitoringEvents.forEach(function (event) {\n      topology.on(event, function (object1, object2) {\n        if (event === 'open') {\n          collectedEvents.push({\n            event: event,\n            object1: mongoClient\n          });\n        } else {\n          collectedEvents.push({\n            event: event,\n            object1: object1,\n            object2: object2\n          });\n        }\n      });\n    });\n  }\n\n  return collectedEvents;\n}\n/**\n * Connect to MongoDB using a url as documented at\n *\n *  docs.mongodb.org/manual/reference/connection-string/\n *\n * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver\n *\n * @method\n * @param {MongoClient} mongoClient The MongoClient instance with which to connect.\n * @param {string} url The connection URI string\n * @param {object} [options] Optional settings. See MongoClient.prototype.connect for a list of options.\n * @param {MongoClient~connectCallback} [callback] The command result callback\n */\n\n\nfunction connect(mongoClient, url, options, callback) {\n  options = Object.assign({}, options); // If callback is null throw an exception\n\n  if (callback == null) {\n    throw new Error('no callback function provided');\n  } // Get a logger for MongoClient\n\n\n  var logger = Logger('MongoClient', options); // Did we pass in a Server/ReplSet/Mongos\n\n  if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {\n    return connectWithUrl(mongoClient, url, options, connectCallback);\n  }\n\n  var parseFn = options.useNewUrlParser ? parse : legacyParse;\n  var transform = options.useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;\n  parseFn(url, options, function (err, _object) {\n    // Do not attempt to connect if parsing error\n    if (err) return callback(err); // Flatten\n\n    var object = transform(_object); // Parse the string\n\n    var _finalOptions = createUnifiedOptions(object, options); // Check if we have connection and socket timeout set\n\n\n    if (_finalOptions.socketTimeoutMS == null) _finalOptions.socketTimeoutMS = 360000;\n    if (_finalOptions.connectTimeoutMS == null) _finalOptions.connectTimeoutMS = 30000;\n\n    if (_finalOptions.db_options && _finalOptions.db_options.auth) {\n      delete _finalOptions.db_options.auth;\n    } // Store the merged options object\n\n\n    mongoClient.s.options = _finalOptions; // Failure modes\n\n    if (object.servers.length === 0) {\n      return callback(new Error('connection string must contain at least one seed host'));\n    } // Do we have a replicaset then skip discovery and go straight to connectivity\n\n\n    if (_finalOptions.replicaSet || _finalOptions.rs_name) {\n      return createTopology(mongoClient, 'replicaset', _finalOptions, connectHandler(mongoClient, _finalOptions, connectCallback));\n    } else if (object.servers.length > 1) {\n      return createTopology(mongoClient, 'mongos', _finalOptions, connectHandler(mongoClient, _finalOptions, connectCallback));\n    } else {\n      return createServer(mongoClient, _finalOptions, connectHandler(mongoClient, _finalOptions, connectCallback));\n    }\n  });\n\n  function connectCallback(err, topology) {\n    var warningMessage = \"seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name\";\n\n    if (err && err.message === 'no mongos proxies found in seed list') {\n      if (logger.isWarn()) {\n        logger.warn(warningMessage);\n      } // Return a more specific error message for MongoClient.connect\n\n\n      return callback(new MongoError(warningMessage));\n    } // Return the error and db instance\n\n\n    callback(err, topology);\n  }\n}\n\nfunction connectHandler(client, options, callback) {\n  return function (err, topology) {\n    if (err) {\n      return handleConnectCallback(err, topology, callback);\n    } // No authentication just reconnect\n\n\n    if (!options.auth) {\n      return handleConnectCallback(err, topology, callback);\n    } // Authenticate\n\n\n    authenticate(client, options.user, options.password, options, function (err, success) {\n      if (success) {\n        handleConnectCallback(null, topology, callback);\n      } else {\n        if (topology) topology.close();\n        var authError = err ? err : new Error('Could not authenticate user ' + options.auth[0]);\n        handleConnectCallback(authError, topology, callback);\n      }\n    });\n  };\n}\n/**\n * Connect to MongoDB using a url as documented at\n *\n *  docs.mongodb.org/manual/reference/connection-string/\n *\n * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver\n *\n * @method\n * @param {MongoClient} mongoClient The MongoClient instance with which to connect.\n * @param {MongoClient~connectCallback} [callback] The command result callback\n */\n\n\nfunction connectOp(mongoClient, err, callback) {\n  // Did we have a validation error\n  if (err) return callback(err); // Fallback to callback based connect\n\n  connect(mongoClient, mongoClient.s.url, mongoClient.s.options, function (err) {\n    if (err) return callback(err);\n    callback(null, mongoClient);\n  });\n}\n\nfunction connectWithUrl(mongoClient, url, options, connectCallback) {\n  // Set the topology\n  assignTopology(mongoClient, url); // Add listeners\n\n  addListeners(mongoClient, url); // Propagate the events to the client\n\n  relayEvents(mongoClient, url);\n  var finalOptions = Object.assign({}, options); // If we have a readPreference passed in by the db options, convert it from a string\n\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\n    finalOptions.readPreference = new ReadPreference(options.readPreference || options.read_preference);\n  } // Connect\n\n\n  return url.connect(finalOptions, connectHandler(mongoClient, finalOptions, function (err, topology) {\n    if (err) return connectCallback(err, topology);\n\n    if (finalOptions.user || finalOptions.password || finalOptions.authMechanism) {\n      return authenticate(mongoClient, finalOptions.user, finalOptions.password, finalOptions, function (err) {\n        if (err) return connectCallback(err, topology);\n        connectCallback(err, topology);\n      });\n    }\n\n    connectCallback(err, topology);\n  }));\n}\n\nfunction createListener(mongoClient, event) {\n  var eventSet = new Set(['all', 'fullsetup', 'open', 'reconnect']);\n  return function (v1, v2) {\n    if (eventSet.has(event)) {\n      return mongoClient.emit(event, mongoClient);\n    }\n\n    mongoClient.emit(event, v1, v2);\n  };\n}\n\nfunction createServer(mongoClient, options, callback) {\n  // Pass in the promise library\n  options.promiseLibrary = mongoClient.s.promiseLibrary; // Set default options\n\n  var servers = translateOptions(options);\n  var server = servers[0]; // Propagate the events to the client\n\n  var collectedEvents = collectEvents(mongoClient, server); // Connect to topology\n\n  server.connect(options, function (err, topology) {\n    if (err) {\n      server.close(true);\n      return callback(err);\n    } // Clear out all the collected event listeners\n\n\n    clearAllEvents(server); // Relay all the events\n\n    relayEvents(mongoClient, server); // Add listeners\n\n    addListeners(mongoClient, server); // Check if we are really speaking to a mongos\n\n    var ismaster = topology.lastIsMaster(); // Set the topology\n\n    assignTopology(mongoClient, topology); // Do we actually have a mongos\n\n    if (ismaster && ismaster.msg === 'isdbgrid') {\n      // Destroy the current connection\n      topology.close(); // Create mongos connection instead\n\n      return createTopology(mongoClient, 'mongos', options, callback);\n    } // Fire all the events\n\n\n    replayEvents(mongoClient, collectedEvents); // Otherwise callback\n\n    callback(err, topology);\n  });\n}\n\nfunction createTopology(mongoClient, topologyType, options, callback) {\n  // Pass in the promise library\n  options.promiseLibrary = mongoClient.s.promiseLibrary;\n  var translationOptions = {};\n  if (topologyType === 'unified') translationOptions.createServers = false; // Set default options\n\n  var servers = translateOptions(options, translationOptions); // Create the topology\n\n  var topology;\n\n  if (topologyType === 'mongos') {\n    topology = new Mongos(servers, options);\n  } else if (topologyType === 'replicaset') {\n    topology = new ReplSet(servers, options);\n  } // Add listeners\n\n\n  addListeners(mongoClient, topology); // Propagate the events to the client\n\n  relayEvents(mongoClient, topology); // Open the connection\n\n  topology.connect(options, function (err, newTopology) {\n    if (err) {\n      topology.close(true);\n      return callback(err);\n    }\n\n    assignTopology(mongoClient, newTopology);\n    callback(null, newTopology);\n  });\n}\n\nfunction createUnifiedOptions(finalOptions, options) {\n  var childOptions = ['mongos', 'server', 'db', 'replset', 'db_options', 'server_options', 'rs_options', 'mongos_options'];\n  var noMerge = ['readconcern', 'compression'];\n\n  for (var name in options) {\n    if (noMerge.indexOf(name.toLowerCase()) !== -1) {\n      finalOptions[name] = options[name];\n    } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {\n      finalOptions = mergeOptions(finalOptions, options[name], false);\n    } else {\n      if (options[name] && typeof options[name] === 'object' && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) {\n        finalOptions = mergeOptions(finalOptions, options[name], true);\n      } else {\n        finalOptions[name] = options[name];\n      }\n    }\n  }\n\n  return finalOptions;\n}\n\nfunction handleConnectCallback(err, topology, callback) {\n  return process.nextTick(function () {\n    try {\n      callback(err, topology);\n    } catch (err) {\n      if (topology) topology.close();\n      throw err;\n    }\n  });\n}\n\nfunction legacyTransformUrlOptions(object) {\n  return mergeOptions(createUnifiedOptions({}, object), object, false);\n}\n/**\n * Logout user from server, fire off on all connections and remove all auth info.\n *\n * @method\n * @param {MongoClient} mongoClient The MongoClient instance on which to logout.\n * @param {object} [options] Optional settings. See MongoClient.prototype.logout for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction logout(mongoClient, dbName, callback) {\n  mongoClient.topology.logout(dbName, function (err) {\n    if (err) return callback(err);\n    callback(null, true);\n  });\n}\n\nfunction mergeOptions(target, source, flatten) {\n  for (var name in source) {\n    if (source[name] && typeof source[name] === 'object' && flatten) {\n      target = mergeOptions(target, source[name], flatten);\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n}\n\nfunction relayEvents(mongoClient, topology) {\n  var serverOrCommandEvents = ['serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'commandStarted', 'commandSucceeded', 'commandFailed', 'joined', 'left', 'ping', 'ha'];\n  serverOrCommandEvents.forEach(function (event) {\n    topology.on(event, function (object1, object2) {\n      mongoClient.emit(event, object1, object2);\n    });\n  });\n} //\n// Replay any events due to single server connection switching to Mongos\n//\n\n\nfunction replayEvents(mongoClient, events) {\n  for (var i = 0; i < events.length; i++) {\n    mongoClient.emit(events[i].event, events[i].object1, events[i].object2);\n  }\n}\n\nvar LEGACY_OPTIONS_MAP = validOptionNames.reduce(function (obj, name) {\n  obj[name.toLowerCase()] = name;\n  return obj;\n}, {});\n\nfunction transformUrlOptions(_object) {\n  var object = Object.assign({\n    servers: _object.hosts\n  }, _object.options);\n\n  for (var name in object) {\n    var camelCaseName = LEGACY_OPTIONS_MAP[name];\n\n    if (camelCaseName) {\n      object[camelCaseName] = object[name];\n    }\n  }\n\n  if (_object.auth) {\n    var auth = _object.auth;\n\n    for (var i in auth) {\n      if (auth[i]) {\n        object[i] = auth[i];\n      }\n    }\n\n    if (auth.username) {\n      object.auth = auth;\n      object.user = auth.username;\n    }\n\n    if (auth.db) {\n      object.authSource = object.authSource || auth.db;\n    }\n  }\n\n  if (_object.defaultDatabase) {\n    object.dbName = _object.defaultDatabase;\n  }\n\n  if (object.maxpoolsize) {\n    object.poolSize = object.maxpoolsize;\n  }\n\n  if (object.readconcernlevel) {\n    object.readConcern = {\n      level: object.readconcernlevel\n    };\n  }\n\n  if (object.wtimeoutms) {\n    object.wtimeout = object.wtimeoutms;\n  }\n\n  return object;\n}\n\nfunction translateOptions(options, translationOptions) {\n  translationOptions = Object.assign({}, {\n    createServers: true\n  }, translationOptions); // If we have a readPreference passed in by the db options\n\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\n    options.readPreference = new ReadPreference(options.readPreference || options.read_preference);\n  } // Do we have readPreference tags, add them\n\n\n  if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {\n    options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;\n  } // Do we have maxStalenessSeconds\n\n\n  if (options.maxStalenessSeconds) {\n    options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;\n  } // Set the socket and connection timeouts\n\n\n  if (options.socketTimeoutMS == null) options.socketTimeoutMS = 360000;\n  if (options.connectTimeoutMS == null) options.connectTimeoutMS = 30000;\n\n  if (!translationOptions.createServers) {\n    return;\n  } // Create server instances\n\n\n  return options.servers.map(function (serverObj) {\n    return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options) : new Server(serverObj.host, serverObj.port, options);\n  });\n} // Validate options object\n\n\nfunction validOptions(options) {\n  var _validOptions = validOptionNames.concat(legacyOptionNames);\n\n  for (var name in options) {\n    if (ignoreOptionNames.indexOf(name) !== -1) {\n      continue;\n    }\n\n    if (_validOptions.indexOf(name) === -1 && options.validateOptions) {\n      return new MongoError(\"option \".concat(name, \" is not supported\"));\n    } else if (_validOptions.indexOf(name) === -1) {\n      console.warn(\"the options [\".concat(name, \"] is not supported\"));\n    }\n\n    if (legacyOptionNames.indexOf(name) !== -1) {\n      console.warn(\"the server/replset/mongos/db options are deprecated, \" + \"all their options are supported at the top level of the options object [\".concat(validOptionNames, \"]\"));\n    }\n  }\n}\n\nmodule.exports = {\n  connectOp: connectOp,\n  logout: logout,\n  validOptions: validOptions\n};","map":null,"metadata":{},"sourceType":"script"}