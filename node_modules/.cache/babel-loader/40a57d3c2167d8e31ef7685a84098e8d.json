{"ast":null,"code":"'use strict';\n\nvar f = require('util').format,\n    crypto = require('crypto'),\n    Query = require('../connection/commands').Query,\n    MongoError = require('../error').MongoError;\n\nvar AuthSession = function AuthSession(db, username, password) {\n  this.db = db;\n  this.username = username;\n  this.password = password;\n};\n\nAuthSession.prototype.equal = function (session) {\n  return session.db === this.db && session.username === this.username && session.password === this.password;\n};\n/**\n * Creates a new MongoCR authentication mechanism\n * @class\n * @return {MongoCR} A cursor instance\n */\n\n\nvar MongoCR = function MongoCR(bson) {\n  this.bson = bson;\n  this.authStore = [];\n}; // Add to store only if it does not exist\n\n\nvar addAuthSession = function addAuthSession(authStore, session) {\n  var found = false;\n\n  for (var i = 0; i < authStore.length; i++) {\n    if (authStore[i].equal(session)) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) authStore.push(session);\n};\n/**\n * Authenticate\n * @method\n * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on\n * @param {[]Connections} connections Connections to authenticate using this authenticator\n * @param {string} db Name of the database\n * @param {string} username Username\n * @param {string} password Password\n * @param {authResultCallback} callback The callback to return the result from the authentication\n * @return {object}\n */\n\n\nMongoCR.prototype.auth = function (server, connections, db, username, password, callback) {\n  var self = this; // Total connections\n\n  var count = connections.length;\n  if (count === 0) return callback(null, null); // Valid connections\n\n  var numberOfValidConnections = 0;\n  var errorObject = null; // For each connection we need to authenticate\n\n  while (connections.length > 0) {\n    // Execute MongoCR\n    var executeMongoCR = function executeMongoCR(connection) {\n      // Write the commmand on the connection\n      server(connection, new Query(self.bson, f('%s.$cmd', db), {\n        getnonce: 1\n      }, {\n        numberToSkip: 0,\n        numberToReturn: 1\n      }), function (err, r) {\n        var nonce = null;\n        var key = null; // Adjust the number of connections left\n        // Get nonce\n\n        if (err == null) {\n          nonce = r.result.nonce; // Use node md5 generator\n\n          var md5 = crypto.createHash('md5'); // Generate keys used for authentication\n\n          md5.update(username + ':mongo:' + password, 'utf8');\n          var hash_password = md5.digest('hex'); // Final key\n\n          md5 = crypto.createHash('md5');\n          md5.update(nonce + username + hash_password, 'utf8');\n          key = md5.digest('hex');\n        } // Execute command\n        // Write the commmand on the connection\n\n\n        server(connection, new Query(self.bson, f('%s.$cmd', db), {\n          authenticate: 1,\n          user: username,\n          nonce: nonce,\n          key: key\n        }, {\n          numberToSkip: 0,\n          numberToReturn: 1\n        }), function (err, r) {\n          count = count - 1; // If we have an error\n\n          if (err) {\n            errorObject = err;\n          } else if (r.result['$err']) {\n            errorObject = r.result;\n          } else if (r.result['errmsg']) {\n            errorObject = r.result;\n          } else {\n            numberOfValidConnections = numberOfValidConnections + 1;\n          } // We have authenticated all connections\n\n\n          if (count === 0 && numberOfValidConnections > 0) {\n            // Store the auth details\n            addAuthSession(self.authStore, new AuthSession(db, username, password)); // Return correct authentication\n\n            callback(null, true);\n          } else if (count === 0) {\n            if (errorObject == null) errorObject = new MongoError(f('failed to authenticate using mongocr'));\n            callback(errorObject, false);\n          }\n        });\n      });\n    };\n\n    var _execute = function _execute(_connection) {\n      process.nextTick(function () {\n        executeMongoCR(_connection);\n      });\n    };\n\n    _execute(connections.shift());\n  }\n};\n/**\n * Remove authStore credentials\n * @method\n * @param {string} db Name of database we are removing authStore details about\n * @return {object}\n */\n\n\nMongoCR.prototype.logout = function (dbName) {\n  this.authStore = this.authStore.filter(function (x) {\n    return x.db !== dbName;\n  });\n};\n/**\n * Re authenticate pool\n * @method\n * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on\n * @param {[]Connections} connections Connections to authenticate using this authenticator\n * @param {authResultCallback} callback The callback to return the result from the authentication\n * @return {object}\n */\n\n\nMongoCR.prototype.reauthenticate = function (server, connections, callback) {\n  var authStore = this.authStore.slice(0);\n  var count = authStore.length;\n  if (count === 0) return callback(null, null); // Iterate over all the auth details stored\n\n  for (var i = 0; i < authStore.length; i++) {\n    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function (err) {\n      count = count - 1; // Done re-authenticating\n\n      if (count === 0) {\n        callback(err, null);\n      }\n    });\n  }\n};\n/**\n * This is a result from a authentication strategy\n *\n * @callback authResultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {boolean} result The result of the authentication process\n */\n\n\nmodule.exports = MongoCR;","map":null,"metadata":{},"sourceType":"script"}