{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits;\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Connection = require('./connection');\n\nvar MongoError = require('../error').MongoError;\n\nvar MongoNetworkError = require('../error').MongoNetworkError;\n\nvar MongoWriteConcernError = require('../error').MongoWriteConcernError;\n\nvar Logger = require('./logger');\n\nvar f = require('util').format;\n\nvar Query = require('./commands').Query;\n\nvar CommandResult = require('./command_result');\n\nvar MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nvar opcodes = require('../wireprotocol/shared').opcodes;\n\nvar compress = require('../wireprotocol/compression').compress;\n\nvar compressorIDs = require('../wireprotocol/compression').compressorIDs;\n\nvar uncompressibleCommands = require('../wireprotocol/compression').uncompressibleCommands;\n\nvar resolveClusterTime = require('../topologies/shared').resolveClusterTime;\n\nvar apm = require('./apm');\n\nvar defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar DESTROYING = 'destroying';\nvar DESTROYED = 'destroyed';\nvar _id = 0;\n\nfunction hasSessionSupport(topology) {\n  if (topology == null) return false;\n  return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;\n}\n/**\n * Creates a new Pool instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Max server connection pool size\n * @param {number} [options.minSize=0] Minimum server connection pool size\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\n * @param {number} [options.monitoringSocketTimeout=30000] TCP Socket timeout setting for replicaset monitoring socket\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passPhrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @fires Pool#connect\n * @fires Pool#close\n * @fires Pool#error\n * @fires Pool#timeout\n * @fires Pool#parseError\n * @return {Pool} A cursor instance\n */\n\n\nvar Pool = function Pool(topology, options) {\n  // Add event listener\n  EventEmitter.call(this); // Store topology for later use\n\n  this.topology = topology; // Add the options\n\n  this.options = Object.assign({\n    // Host and port settings\n    host: 'localhost',\n    port: 27017,\n    // Pool default max size\n    size: 5,\n    // Pool default min size\n    minSize: 0,\n    // socket settings\n    connectionTimeout: 30000,\n    socketTimeout: 360000,\n    keepAlive: true,\n    keepAliveInitialDelay: 300000,\n    noDelay: true,\n    // SSL Settings\n    ssl: false,\n    checkServerIdentity: true,\n    ca: null,\n    crl: null,\n    cert: null,\n    key: null,\n    passPhrase: null,\n    rejectUnauthorized: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    // Reconnection options\n    reconnect: true,\n    reconnectInterval: 1000,\n    reconnectTries: 30,\n    // Enable domains\n    domainsEnabled: false\n  }, options); // Identification information\n\n  this.id = _id++; // Current reconnect retries\n\n  this.retriesLeft = this.options.reconnectTries;\n  this.reconnectId = null; // No bson parser passed in\n\n  if (!options.bson || options.bson && (typeof options.bson.serialize !== 'function' || typeof options.bson.deserialize !== 'function')) {\n    throw new Error('must pass in valid bson parser');\n  } // Logger instance\n\n\n  this.logger = Logger('Pool', options); // Pool state\n\n  this.state = DISCONNECTED; // Connections\n\n  this.availableConnections = [];\n  this.inUseConnections = [];\n  this.connectingConnections = []; // Currently executing\n\n  this.executing = false; // Operation work queue\n\n  this.queue = []; // All the authProviders\n\n  this.authProviders = options.authProviders || defaultAuthProviders(options.bson); // Contains the reconnect connection\n\n  this.reconnectConnection = null; // Are we currently authenticating\n\n  this.authenticating = false;\n  this.loggingout = false;\n  this.nonAuthenticatedConnections = [];\n  this.authenticatingTimestamp = null; // Number of consecutive timeouts caught\n\n  this.numberOfConsecutiveTimeouts = 0; // Current pool Index\n\n  this.connectionIndex = 0;\n};\n\ninherits(Pool, EventEmitter);\nObject.defineProperty(Pool.prototype, 'size', {\n  enumerable: true,\n  get: function get() {\n    return this.options.size;\n  }\n});\nObject.defineProperty(Pool.prototype, 'minSize', {\n  enumerable: true,\n  get: function get() {\n    return this.options.minSize;\n  }\n});\nObject.defineProperty(Pool.prototype, 'connectionTimeout', {\n  enumerable: true,\n  get: function get() {\n    return this.options.connectionTimeout;\n  }\n});\nObject.defineProperty(Pool.prototype, 'socketTimeout', {\n  enumerable: true,\n  get: function get() {\n    return this.options.socketTimeout;\n  }\n});\n\nfunction stateTransition(self, newState) {\n  var legalTransitions = {\n    disconnected: [CONNECTING, DESTROYING, DISCONNECTED],\n    connecting: [CONNECTING, DESTROYING, CONNECTED, DISCONNECTED],\n    connected: [CONNECTED, DISCONNECTED, DESTROYING],\n    destroying: [DESTROYING, DESTROYED],\n    destroyed: [DESTROYED]\n  }; // Get current state\n\n  var legalStates = legalTransitions[self.state];\n\n  if (legalStates && legalStates.indexOf(newState) !== -1) {\n    self.emit('stateChanged', self.state, newState);\n    self.state = newState;\n  } else {\n    self.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]', self.id, self.state, newState, legalStates));\n  }\n}\n\nfunction authenticate(pool, auth, connection, cb) {\n  if (auth[0] === undefined) return cb(null); // We need to authenticate the server\n\n  var mechanism = auth[0];\n  var db = auth[1]; // Validate if the mechanism exists\n\n  if (!pool.authProviders[mechanism]) {\n    throw new MongoError(f('authMechanism %s not supported', mechanism));\n  } // Get the provider\n\n\n  var provider = pool.authProviders[mechanism]; // Authenticate using the provided mechanism\n\n  provider.auth.apply(provider, [write(pool), [connection], db].concat(auth.slice(2)).concat([cb]));\n} // The write function used by the authentication mechanism (bypasses external)\n\n\nfunction write(self) {\n  return function (connection, command, callback) {\n    // Get the raw buffer\n    // Ensure we stop auth if pool was destroyed\n    if (self.state === DESTROYED || self.state === DESTROYING) {\n      return callback(new MongoError('pool destroyed'));\n    } // Set the connection workItem callback\n\n\n    connection.workItems.push({\n      cb: callback,\n      command: true,\n      requestId: command.requestId\n    }); // Write the buffer out to the connection\n\n    connection.write(command.toBin());\n  };\n}\n\nfunction reauthenticate(pool, connection, cb) {\n  // Authenticate\n  function authenticateAgainstProvider(pool, connection, providers, cb) {\n    // Finished re-authenticating against providers\n    if (providers.length === 0) return cb(); // Get the provider name\n\n    var provider = pool.authProviders[providers.pop()]; // Auth provider\n\n    provider.reauthenticate(write(pool), [connection], function (err) {\n      // We got an error return immediately\n      if (err) return cb(err); // Continue authenticating the connection\n\n      authenticateAgainstProvider(pool, connection, providers, cb);\n    });\n  } // Start re-authenticating process\n\n\n  authenticateAgainstProvider(pool, connection, Object.keys(pool.authProviders), cb);\n}\n\nfunction connectionFailureHandler(self, event) {\n  return function (err) {\n    if (this._connectionFailHandled) return;\n    this._connectionFailHandled = true; // Destroy the connection\n\n    this.destroy(); // Remove the connection\n\n    removeConnection(self, this); // Flush all work Items on this connection\n\n    while (this.workItems.length > 0) {\n      var workItem = this.workItems.shift();\n      if (workItem.cb) workItem.cb(err);\n    } // Did we catch a timeout, increment the numberOfConsecutiveTimeouts\n\n\n    if (event === 'timeout') {\n      self.numberOfConsecutiveTimeouts = self.numberOfConsecutiveTimeouts + 1; // Have we timed out more than reconnectTries in a row ?\n      // Force close the pool as we are trying to connect to tcp sink hole\n\n      if (self.numberOfConsecutiveTimeouts > self.options.reconnectTries) {\n        self.numberOfConsecutiveTimeouts = 0; // Destroy all connections and pool\n\n        self.destroy(true); // Emit close event\n\n        return self.emit('close', self);\n      }\n    } // No more socket available propegate the event\n\n\n    if (self.socketCount() === 0) {\n      if (self.state !== DESTROYED && self.state !== DESTROYING) {\n        stateTransition(self, DISCONNECTED);\n      } // Do not emit error events, they are always close events\n      // do not trigger the low level error handler in node\n\n\n      event = event === 'error' ? 'close' : event;\n      self.emit(event, err);\n    } // Start reconnection attempts\n\n\n    if (!self.reconnectId && self.options.reconnect) {\n      self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);\n    } // Do we need to do anything to maintain the minimum pool size\n\n\n    var totalConnections = self.availableConnections.length + self.connectingConnections.length + self.inUseConnections.length;\n\n    if (totalConnections < self.minSize) {\n      _createConnection(self);\n    }\n  };\n}\n\nfunction attemptReconnect(self) {\n  return function () {\n    self.emit('attemptReconnect', self);\n    if (self.state === DESTROYED || self.state === DESTROYING) return; // We are connected do not try again\n\n    if (self.isConnected()) {\n      self.reconnectId = null;\n      return;\n    } // If we have failure schedule a retry\n\n\n    function _connectionFailureHandler(self) {\n      return function () {\n        if (this._connectionFailHandled) return;\n        this._connectionFailHandled = true; // Destroy the connection\n\n        this.destroy(); // Count down the number of reconnects\n\n        self.retriesLeft = self.retriesLeft - 1; // How many retries are left\n\n        if (self.retriesLeft <= 0) {\n          // Destroy the instance\n          self.destroy(); // Emit close event\n\n          self.emit('reconnectFailed', new MongoNetworkError(f('failed to reconnect after %s attempts with interval %s ms', self.options.reconnectTries, self.options.reconnectInterval)));\n        } else {\n          self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);\n        }\n      };\n    } // Got a connect handler\n\n\n    function _connectHandler(self) {\n      return function () {\n        // Assign\n        var connection = this; // Pool destroyed stop the connection\n\n        if (self.state === DESTROYED || self.state === DESTROYING) {\n          return connection.destroy();\n        } // Clear out all handlers\n\n\n        handlers.forEach(function (event) {\n          connection.removeAllListeners(event);\n        }); // Reset reconnect id\n\n        self.reconnectId = null; // Apply pool connection handlers\n\n        connection.on('error', connectionFailureHandler(self, 'error'));\n        connection.on('close', connectionFailureHandler(self, 'close'));\n        connection.on('timeout', connectionFailureHandler(self, 'timeout'));\n        connection.on('parseError', connectionFailureHandler(self, 'parseError')); // Apply any auth to the connection\n\n        reauthenticate(self, this, function () {\n          // Reset retries\n          self.retriesLeft = self.options.reconnectTries; // Push to available connections\n\n          self.availableConnections.push(connection); // Set the reconnectConnection to null\n\n          self.reconnectConnection = null; // Emit reconnect event\n\n          self.emit('reconnect', self); // Trigger execute to start everything up again\n\n          _execute(self)();\n        });\n      };\n    } // Create a connection\n\n\n    self.reconnectConnection = new Connection(messageHandler(self), self.options); // Add handlers\n\n    self.reconnectConnection.on('close', _connectionFailureHandler(self, 'close'));\n    self.reconnectConnection.on('error', _connectionFailureHandler(self, 'error'));\n    self.reconnectConnection.on('timeout', _connectionFailureHandler(self, 'timeout'));\n    self.reconnectConnection.on('parseError', _connectionFailureHandler(self, 'parseError')); // On connection\n\n    self.reconnectConnection.on('connect', _connectHandler(self)); // Attempt connection\n\n    self.reconnectConnection.connect();\n  };\n}\n\nfunction moveConnectionBetween(connection, from, to) {\n  var index = from.indexOf(connection); // Move the connection from connecting to available\n\n  if (index !== -1) {\n    from.splice(index, 1);\n    to.push(connection);\n  }\n}\n\nfunction messageHandler(self) {\n  return function (message, connection) {\n    // workItem to execute\n    var workItem = null; // Locate the workItem\n\n    for (var i = 0; i < connection.workItems.length; i++) {\n      if (connection.workItems[i].requestId === message.responseTo) {\n        // Get the callback\n        workItem = connection.workItems[i]; // Remove from list of workItems\n\n        connection.workItems.splice(i, 1);\n      }\n    } // Reset timeout counter\n\n\n    self.numberOfConsecutiveTimeouts = 0; // Reset the connection timeout if we modified it for\n    // this operation\n\n    if (workItem && workItem.socketTimeout) {\n      connection.resetSocketTimeout();\n    } // Log if debug enabled\n\n\n    if (self.logger.isDebug()) {\n      self.logger.debug(f('message [%s] received from %s:%s', message.raw.toString('hex'), self.options.host, self.options.port));\n    } // Authenticate any straggler connections\n\n\n    function authenticateStragglers(self, connection, callback) {\n      // Get any non authenticated connections\n      var connections = self.nonAuthenticatedConnections.slice(0);\n      var nonAuthenticatedConnections = self.nonAuthenticatedConnections;\n      self.nonAuthenticatedConnections = []; // Establish if the connection need to be authenticated\n      // Add to authentication list if\n      // 1. we were in an authentication process when the operation was executed\n      // 2. our current authentication timestamp is from the workItem one, meaning an auth has happened\n\n      if (connection.workItems.length === 1 && (connection.workItems[0].authenticating === true || typeof connection.workItems[0].authenticatingTimestamp === 'number' && connection.workItems[0].authenticatingTimestamp !== self.authenticatingTimestamp)) {\n        // Add connection to the list\n        connections.push(connection);\n      } // No connections need to be re-authenticated\n\n\n      if (connections.length === 0) {\n        // Release the connection back to the pool\n        moveConnectionBetween(connection, self.inUseConnections, self.availableConnections); // Finish\n\n        return callback();\n      } // Apply re-authentication to all connections before releasing back to pool\n\n\n      var connectionCount = connections.length; // Authenticate all connections\n\n      for (var i = 0; i < connectionCount; i++) {\n        reauthenticate(self, connections[i], function () {\n          connectionCount = connectionCount - 1;\n\n          if (connectionCount === 0) {\n            // Put non authenticated connections in available connections\n            self.availableConnections = self.availableConnections.concat(nonAuthenticatedConnections); // Release the connection back to the pool\n\n            moveConnectionBetween(connection, self.inUseConnections, self.availableConnections); // Return\n\n            callback();\n          }\n        });\n      }\n    }\n\n    function handleOperationCallback(self, cb, err, result) {\n      // No domain enabled\n      if (!self.options.domainsEnabled) {\n        return process.nextTick(function () {\n          return cb(err, result);\n        });\n      } // Domain enabled just call the callback\n\n\n      cb(err, result);\n    }\n\n    authenticateStragglers(self, connection, function () {\n      // Keep executing, ensure current message handler does not stop execution\n      if (!self.executing) {\n        process.nextTick(function () {\n          _execute(self)();\n        });\n      } // Time to dispatch the message if we have a callback\n\n\n      if (workItem && !workItem.immediateRelease) {\n        try {\n          // Parse the message according to the provided options\n          message.parse(workItem);\n        } catch (err) {\n          return handleOperationCallback(self, workItem.cb, new MongoError(err));\n        } // Look for clusterTime, and operationTime and update them if necessary\n\n\n        if (message.documents[0]) {\n          if (message.documents[0].$clusterTime) {\n            var $clusterTime = message.documents[0].$clusterTime;\n            self.topology.clusterTime = $clusterTime;\n\n            if (workItem.session != null) {\n              resolveClusterTime(workItem.session, $clusterTime);\n            }\n          }\n\n          if (message.documents[0].operationTime && workItem.session && workItem.session.supports.causalConsistency) {\n            workItem.session.advanceOperationTime(message.documents[0].operationTime);\n          }\n        } // Establish if we have an error\n\n\n        if (workItem.command && message.documents[0]) {\n          var responseDoc = message.documents[0];\n\n          if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {\n            return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));\n          }\n\n          if (responseDoc.writeConcernError) {\n            var err = responseDoc.ok === 1 ? new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc) : new MongoWriteConcernError(responseDoc.writeConcernError);\n            return handleOperationCallback(self, workItem.cb, err);\n          }\n        } // Add the connection details\n\n\n        message.hashedName = connection.hashedName; // Return the documents\n\n        handleOperationCallback(self, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));\n      }\n    });\n  };\n}\n/**\n * Return the total socket count in the pool.\n * @method\n * @return {Number} The number of socket available.\n */\n\n\nPool.prototype.socketCount = function () {\n  return this.availableConnections.length + this.inUseConnections.length; // + this.connectingConnections.length;\n};\n/**\n * Return all pool connections\n * @method\n * @return {Connection[]} The pool connections\n */\n\n\nPool.prototype.allConnections = function () {\n  return this.availableConnections.concat(this.inUseConnections).concat(this.connectingConnections);\n};\n/**\n * Get a pool connection (round-robin)\n * @method\n * @return {Connection}\n */\n\n\nPool.prototype.get = function () {\n  return this.allConnections()[0];\n};\n/**\n * Is the pool connected\n * @method\n * @return {boolean}\n */\n\n\nPool.prototype.isConnected = function () {\n  // We are in a destroyed state\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    return false;\n  } // Get connections\n\n\n  var connections = this.availableConnections.concat(this.inUseConnections); // Check if we have any connected connections\n\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i].isConnected()) return true;\n  } // Might be authenticating, but we are still connected\n\n\n  if (connections.length === 0 && this.authenticating) {\n    return true;\n  } // Not connected\n\n\n  return false;\n};\n/**\n * Was the pool destroyed\n * @method\n * @return {boolean}\n */\n\n\nPool.prototype.isDestroyed = function () {\n  return this.state === DESTROYED || this.state === DESTROYING;\n};\n/**\n * Is the pool in a disconnected state\n * @method\n * @return {boolean}\n */\n\n\nPool.prototype.isDisconnected = function () {\n  return this.state === DISCONNECTED;\n};\n/**\n * Connect pool\n * @method\n */\n\n\nPool.prototype.connect = function () {\n  if (this.state !== DISCONNECTED) {\n    throw new MongoError('connection in unlawful state ' + this.state);\n  }\n\n  var self = this; // Transition to connecting state\n\n  stateTransition(this, CONNECTING); // Create an array of the arguments\n\n  var args = Array.prototype.slice.call(arguments, 0); // Create a connection\n\n  var connection = new Connection(messageHandler(self), this.options); // Add to list of connections\n\n  this.connectingConnections.push(connection); // Add listeners to the connection\n\n  connection.once('connect', function (connection) {\n    if (self.state === DESTROYED || self.state === DESTROYING) return self.destroy(); // If we are in a topology, delegate the auth to it\n    // This is to avoid issues where we would auth against an\n    // arbiter\n\n    if (self.options.inTopology) {\n      // Set connected mode\n      stateTransition(self, CONNECTED); // Move the active connection\n\n      moveConnectionBetween(connection, self.connectingConnections, self.availableConnections); // Emit the connect event\n\n      return self.emit('connect', self);\n    } // Apply any store credentials\n\n\n    reauthenticate(self, connection, function (err) {\n      if (self.state === DESTROYED || self.state === DESTROYING) return self.destroy(); // We have an error emit it\n\n      if (err) {\n        // Destroy the pool\n        self.destroy(); // Emit the error\n\n        return self.emit('error', err);\n      } // Authenticate\n\n\n      authenticate(self, args, connection, function (err) {\n        if (self.state === DESTROYED || self.state === DESTROYING) return self.destroy(); // We have an error emit it\n\n        if (err) {\n          // Destroy the pool\n          self.destroy(); // Emit the error\n\n          return self.emit('error', err);\n        } // Set connected mode\n\n\n        stateTransition(self, CONNECTED); // Move the active connection\n\n        moveConnectionBetween(connection, self.connectingConnections, self.availableConnections); // if we have a minPoolSize, create a connection\n\n        if (self.minSize) {\n          for (var i = 0; i < self.minSize; i++) {\n            _createConnection(self);\n          }\n        } // Emit the connect event\n\n\n        self.emit('connect', self);\n      });\n    });\n  }); // Add error handlers\n\n  connection.once('error', connectionFailureHandler(this, 'error'));\n  connection.once('close', connectionFailureHandler(this, 'close'));\n  connection.once('timeout', connectionFailureHandler(this, 'timeout'));\n  connection.once('parseError', connectionFailureHandler(this, 'parseError'));\n\n  try {\n    connection.connect();\n  } catch (err) {\n    // SSL or something threw on connect\n    process.nextTick(function () {\n      self.emit('error', err);\n    });\n  }\n};\n/**\n * Authenticate using a specified mechanism\n * @method\n * @param {string} mechanism The Auth mechanism we are invoking\n * @param {string} db The db we are invoking the mechanism against\n * @param {...object} param Parameters for the specific mechanism\n * @param {authResultCallback} callback A callback function\n */\n\n\nPool.prototype.auth = function (mechanism) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop(); // If we don't have the mechanism fail\n\n  if (self.authProviders[mechanism] == null && mechanism !== 'default') {\n    throw new MongoError(f('auth provider %s does not exist', mechanism));\n  } // Signal that we are authenticating a new set of credentials\n\n\n  this.authenticating = true;\n  this.authenticatingTimestamp = new Date().getTime(); // Authenticate all live connections\n\n  function authenticateLiveConnections(self, args, cb) {\n    // Get the current viable connections\n    var connections = self.allConnections(); // Allow nothing else to use the connections while we authenticate them\n\n    self.availableConnections = [];\n    self.inUseConnections = [];\n    self.connectingConnections = [];\n    var connectionsCount = connections.length;\n    var error = null; // No connections available, return\n\n    if (connectionsCount === 0) {\n      self.authenticating = false;\n      return callback(null);\n    } // Authenticate the connections\n\n\n    for (var i = 0; i < connections.length; i++) {\n      authenticate(self, args, connections[i], function (err, result) {\n        connectionsCount = connectionsCount - 1; // Store the error\n\n        if (err) error = err; // Processed all connections\n\n        if (connectionsCount === 0) {\n          // Auth finished\n          self.authenticating = false; // Add the connections back to available connections\n\n          self.availableConnections = self.availableConnections.concat(connections); // We had an error, return it\n\n          if (error) {\n            // Log the error\n            if (self.logger.isError()) {\n              self.logger.error(f('[%s] failed to authenticate against server %s:%s', self.id, self.options.host, self.options.port));\n            }\n\n            return cb(error, result);\n          }\n\n          cb(null, result);\n        }\n      });\n    }\n  } // Wait for a logout in process to happen\n\n\n  function waitForLogout(self, cb) {\n    if (!self.loggingout) return cb();\n    setTimeout(function () {\n      waitForLogout(self, cb);\n    }, 1);\n  } // Wait for loggout to finish\n\n\n  waitForLogout(self, function () {\n    // Authenticate all live connections\n    authenticateLiveConnections(self, args, function (err, result) {\n      // Credentials correctly stored in auth provider if successful\n      // Any new connections will now reauthenticate correctly\n      self.authenticating = false; // Return after authentication connections\n\n      callback(err, result);\n    });\n  });\n};\n/**\n * Logout all users against a database\n * @method\n * @param {string} dbName The database name\n * @param {authResultCallback} callback A callback function\n */\n\n\nPool.prototype.logout = function (dbName, callback) {\n  var self = this;\n\n  if (typeof dbName !== 'string') {\n    throw new MongoError('logout method requires a db name as first argument');\n  }\n\n  if (typeof callback !== 'function') {\n    throw new MongoError('logout method requires a callback');\n  } // Indicate logout in process\n\n\n  this.loggingout = true; // Get all relevant connections\n\n  var connections = self.availableConnections.concat(self.inUseConnections);\n  var count = connections.length; // Store any error\n\n  var error = null; // Send logout command over all the connections\n\n  for (var i = 0; i < connections.length; i++) {\n    write(self)(connections[i], new Query(this.options.bson, f('%s.$cmd', dbName), {\n      logout: 1\n    }, {\n      numberToSkip: 0,\n      numberToReturn: 1\n    }), function (err) {\n      count = count - 1;\n      if (err) error = err;\n\n      if (count === 0) {\n        self.loggingout = false;\n        callback(error);\n      }\n    });\n  }\n};\n/**\n * Unref the pool\n * @method\n */\n\n\nPool.prototype.unref = function () {\n  // Get all the known connections\n  var connections = this.availableConnections.concat(this.inUseConnections).concat(this.connectingConnections);\n  connections.forEach(function (c) {\n    c.unref();\n  });\n}; // Events\n\n\nvar events = ['error', 'close', 'timeout', 'parseError', 'connect']; // Destroy the connections\n\nfunction destroy(self, connections) {\n  // Destroy all connections\n  connections.forEach(function (c) {\n    // Remove all listeners\n    for (var i = 0; i < events.length; i++) {\n      c.removeAllListeners(events[i]);\n    } // Destroy connection\n\n\n    c.destroy();\n  }); // Zero out all connections\n\n  self.inUseConnections = [];\n  self.availableConnections = [];\n  self.nonAuthenticatedConnections = [];\n  self.connectingConnections = []; // Set state to destroyed\n\n  stateTransition(self, DESTROYED);\n}\n/**\n * Destroy pool\n * @method\n */\n\n\nPool.prototype.destroy = function (force) {\n  var self = this; // Do not try again if the pool is already dead\n\n  if (this.state === DESTROYED || self.state === DESTROYING) return; // Set state to destroyed\n\n  stateTransition(this, DESTROYING); // Are we force closing\n\n  if (force) {\n    // Get all the known connections\n    var connections = self.availableConnections.concat(self.inUseConnections).concat(self.nonAuthenticatedConnections).concat(self.connectingConnections); // Flush any remaining work items with\n    // an error\n\n    while (self.queue.length > 0) {\n      var workItem = self.queue.shift();\n\n      if (typeof workItem.cb === 'function') {\n        workItem.cb(new MongoError('Pool was force destroyed'));\n      }\n    } // Destroy the topology\n\n\n    return destroy(self, connections);\n  } // Clear out the reconnect if set\n\n\n  if (this.reconnectId) {\n    clearTimeout(this.reconnectId);\n  } // If we have a reconnect connection running, close\n  // immediately\n\n\n  if (this.reconnectConnection) {\n    this.reconnectConnection.destroy();\n  } // Wait for the operations to drain before we close the pool\n\n\n  function checkStatus() {\n    flushMonitoringOperations(self.queue);\n\n    if (self.queue.length === 0) {\n      // Get all the known connections\n      var connections = self.availableConnections.concat(self.inUseConnections).concat(self.nonAuthenticatedConnections).concat(self.connectingConnections); // Check if we have any in flight operations\n\n      for (var i = 0; i < connections.length; i++) {\n        // There is an operation still in flight, reschedule a\n        // check waiting for it to drain\n        if (connections[i].workItems.length > 0) {\n          return setTimeout(checkStatus, 1);\n        }\n      }\n\n      destroy(self, connections); // } else if (self.queue.length > 0 && !this.reconnectId) {\n    } else {\n      // Ensure we empty the queue\n      _execute(self)(); // Set timeout\n\n\n      setTimeout(checkStatus, 1);\n    }\n  } // Initiate drain of operations\n\n\n  checkStatus();\n}; // Prepare the buffer that Pool.prototype.write() uses to send to the server\n\n\nvar serializeCommands = function serializeCommands(self, commands, result, callback) {\n  // Base case when there are no more commands to serialize\n  if (commands.length === 0) return callback(null, result); // Pop off the zeroth command and serialize it\n\n  var thisCommand = commands.shift();\n  var originalCommandBuffer = thisCommand.toBin(); // Check whether we and the server have agreed to use a compressor\n\n  if (self.options.agreedCompressor && !hasUncompressibleCommands(thisCommand)) {\n    // Transform originalCommandBuffer into OP_COMPRESSED\n    var concatenatedOriginalCommandBuffer = Buffer.concat(originalCommandBuffer);\n    var messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n    var originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n    compress(self, messageToBeCompressed, function (err, compressedMessage) {\n      if (err) return callback(err, null); // Create the msgHeader of OP_COMPRESSED\n\n      var msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + 9 + compressedMessage.length, 0); // messageLength\n\n      msgHeader.writeInt32LE(thisCommand.requestId, 4); // requestID\n\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n      // Create the compression details of OP_COMPRESSED\n\n      var compressionDetails = Buffer.alloc(9);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n      compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8); // compressorID\n      // Push the concatenation of the OP_COMPRESSED message onto results\n\n      result.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage])); // Continue recursing through the commands array\n\n      serializeCommands(self, commands, result, callback);\n    });\n  } else {\n    // Push the serialization of the command onto results\n    result.push(originalCommandBuffer); // Continue recursing through the commands array\n\n    serializeCommands(self, commands, result, callback);\n  }\n};\n/**\n * Write a message to MongoDB\n * @method\n * @return {Connection}\n */\n\n\nPool.prototype.write = function (commands, options, cb) {\n  var _this = this;\n\n  var self = this; // Ensure we have a callback\n\n  if (typeof options === 'function') {\n    cb = options;\n  } // Always have options\n\n\n  options = options || {}; // We need to have a callback function unless the message returns no response\n\n  if (!(typeof cb === 'function') && !options.noResponse) {\n    throw new MongoError('write method must provide a callback');\n  } // Pool was destroyed error out\n\n\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    // Callback with an error\n    if (cb) {\n      try {\n        cb(new MongoError('pool destroyed'));\n      } catch (err) {\n        process.nextTick(function () {\n          throw err;\n        });\n      }\n    }\n\n    return;\n  }\n\n  if (this.options.domainsEnabled && process.domain && typeof cb === 'function') {\n    // if we have a domain bind to it\n    var oldCb = cb;\n    cb = process.domain.bind(function () {\n      // v8 - argumentsToArray one-liner\n      var args = new Array(arguments.length);\n\n      for (var i = 0; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      } // bounce off event loop so domain switch takes place\n\n\n      process.nextTick(function () {\n        oldCb.apply(null, args);\n      });\n    });\n  } // Do we have an operation\n\n\n  var operation = {\n    cb: cb,\n    raw: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    fullResult: false\n  }; // Set the options for the parsing\n\n  operation.promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true;\n  operation.promoteValues = typeof options.promoteValues === 'boolean' ? options.promoteValues : true;\n  operation.promoteBuffers = typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false;\n  operation.raw = typeof options.raw === 'boolean' ? options.raw : false;\n  operation.immediateRelease = typeof options.immediateRelease === 'boolean' ? options.immediateRelease : false;\n  operation.documentsReturnedIn = options.documentsReturnedIn;\n  operation.command = typeof options.command === 'boolean' ? options.command : false;\n  operation.fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;\n  operation.noResponse = typeof options.noResponse === 'boolean' ? options.noResponse : false;\n  operation.session = options.session || null; // Optional per operation socketTimeout\n\n  operation.socketTimeout = options.socketTimeout;\n  operation.monitoring = options.monitoring; // Custom socket Timeout\n\n  if (options.socketTimeout) {\n    operation.socketTimeout = options.socketTimeout;\n  } // Ensure commands is an array\n\n\n  if (!Array.isArray(commands)) {\n    commands = [commands];\n  } // Get the requestId\n\n\n  operation.requestId = commands[commands.length - 1].requestId;\n\n  if (hasSessionSupport(this.topology)) {\n    var sessionOptions = {};\n\n    if (this.topology.clusterTime) {\n      sessionOptions = {\n        $clusterTime: this.topology.clusterTime\n      };\n    }\n\n    if (operation.session) {\n      // TODO: reenable when sessions development is complete\n      // if (operation.session.topology !== this.topology) {\n      //   return cb(\n      //     new MongoError('Sessions may only be used with the client they were created from')\n      //   );\n      // }\n      if (operation.session.hasEnded) {\n        return cb(new MongoError('Use of expired sessions is not permitted'));\n      }\n\n      if (operation.session.clusterTime && operation.session.clusterTime.clusterTime.greaterThan(sessionOptions.$clusterTime.clusterTime)) {\n        sessionOptions.$clusterTime = operation.session.clusterTime;\n      }\n\n      sessionOptions.lsid = operation.session.id; // update the `lastUse` of the acquired ServerSession\n\n      operation.session.serverSession.lastUse = Date.now();\n    } // decorate the commands with session-specific details\n\n\n    commands.forEach(function (command) {\n      if (command instanceof Query) {\n        if (command.query.$query) {\n          Object.assign(command.query.$query, sessionOptions);\n        } else {\n          Object.assign(command.query, sessionOptions);\n        }\n      } else {\n        Object.assign(command, sessionOptions);\n      }\n    });\n  } // If command monitoring is enabled we need to modify the callback here\n\n\n  if (self.options.monitorCommands) {\n    // NOTE: there is only ever a single command, for some legacy reason I am unaware of we\n    //       treat this as a potential array of commands\n    var command = commands[0];\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operation.started = process.hrtime();\n\n    operation.cb = function (err, reply) {\n      if (err) {\n        self.emit('commandFailed', new apm.CommandFailedEvent(_this, command, err, operation.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          self.emit('commandFailed', new apm.CommandFailedEvent(_this, command, reply.result, operation.started));\n        } else {\n          self.emit('commandSucceeded', new apm.CommandSucceededEvent(_this, command, reply, operation.started));\n        }\n      }\n\n      if (typeof cb === 'function') cb(err, reply);\n    };\n  } // Prepare the operation buffer\n\n\n  serializeCommands(self, commands, [], function (err, serializedCommands) {\n    if (err) throw err; // Set the operation's buffer to the serialization of the commands\n\n    operation.buffer = serializedCommands; // If we have a monitoring operation schedule as the very first operation\n    // Otherwise add to back of queue\n\n    if (options.monitoring) {\n      self.queue.unshift(operation);\n    } else {\n      self.queue.push(operation);\n    } // Attempt to execute the operation\n\n\n    if (!self.executing) {\n      process.nextTick(function () {\n        _execute(self)();\n      });\n    }\n  });\n}; // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\n\nvar hasUncompressibleCommands = function hasUncompressibleCommands(command) {\n  return uncompressibleCommands.some(function (cmd) {\n    return command.query.hasOwnProperty(cmd);\n  });\n}; // Remove connection method\n\n\nfunction remove(connection, connections) {\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i] === connection) {\n      connections.splice(i, 1);\n      return true;\n    }\n  }\n}\n\nfunction removeConnection(self, connection) {\n  if (remove(connection, self.availableConnections)) return;\n  if (remove(connection, self.inUseConnections)) return;\n  if (remove(connection, self.connectingConnections)) return;\n  if (remove(connection, self.nonAuthenticatedConnections)) return;\n} // All event handlers\n\n\nvar handlers = ['close', 'message', 'error', 'timeout', 'parseError', 'connect'];\n\nfunction _createConnection(self) {\n  if (self.state === DESTROYED || self.state === DESTROYING) {\n    return;\n  }\n\n  var connection = new Connection(messageHandler(self), self.options); // Push the connection\n\n  self.connectingConnections.push(connection); // Handle any errors\n\n  var tempErrorHandler = function tempErrorHandler(_connection) {\n    return function () {\n      // Destroy the connection\n      _connection.destroy(); // Remove the connection from the connectingConnections list\n\n\n      removeConnection(self, _connection); // Start reconnection attempts\n\n      if (!self.reconnectId && self.options.reconnect) {\n        self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);\n      }\n    };\n  }; // Handle successful connection\n\n\n  var tempConnectHandler = function tempConnectHandler(_connection) {\n    return function () {\n      // Destroyed state return\n      if (self.state === DESTROYED || self.state === DESTROYING) {\n        // Remove the connection from the list\n        removeConnection(self, _connection);\n        return _connection.destroy();\n      } // Destroy all event emitters\n\n\n      handlers.forEach(function (e) {\n        _connection.removeAllListeners(e);\n      }); // Add the final handlers\n\n      _connection.once('close', connectionFailureHandler(self, 'close'));\n\n      _connection.once('error', connectionFailureHandler(self, 'error'));\n\n      _connection.once('timeout', connectionFailureHandler(self, 'timeout'));\n\n      _connection.once('parseError', connectionFailureHandler(self, 'parseError')); // Signal\n\n\n      reauthenticate(self, _connection, function (err) {\n        if (self.state === DESTROYED || self.state === DESTROYING) {\n          return _connection.destroy();\n        } // Remove the connection from the connectingConnections list\n\n\n        removeConnection(self, _connection); // Handle error\n\n        if (err) {\n          return _connection.destroy();\n        } // If we are c at the moment\n        // Do not automatially put in available connections\n        // As we need to apply the credentials first\n\n\n        if (self.authenticating) {\n          self.nonAuthenticatedConnections.push(_connection);\n        } else {\n          // Push to available\n          self.availableConnections.push(_connection); // Execute any work waiting\n\n          _execute(self)();\n        }\n      });\n    };\n  }; // Add all handlers\n\n\n  connection.once('close', tempErrorHandler(connection));\n  connection.once('error', tempErrorHandler(connection));\n  connection.once('timeout', tempErrorHandler(connection));\n  connection.once('parseError', tempErrorHandler(connection));\n  connection.once('connect', tempConnectHandler(connection)); // Start connection\n\n  connection.connect();\n}\n\nfunction flushMonitoringOperations(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    if (queue[i].monitoring) {\n      var workItem = queue[i];\n      queue.splice(i, 1);\n      workItem.cb(new MongoError({\n        message: 'no connection available for monitoring',\n        driver: true\n      }));\n    }\n  }\n}\n\nfunction _execute(self) {\n  return function () {\n    if (self.state === DESTROYED) return; // Already executing, skip\n\n    if (self.executing) return; // Set pool as executing\n\n    self.executing = true; // Wait for auth to clear before continuing\n\n    function waitForAuth(cb) {\n      if (!self.authenticating) return cb(); // Wait for a milisecond and try again\n\n      setTimeout(function () {\n        waitForAuth(cb);\n      }, 1);\n    } // Block on any auth in process\n\n\n    waitForAuth(function () {\n      // New pool connections are in progress, wait them to finish\n      // before executing any more operation to ensure distribution of\n      // operations\n      if (self.connectingConnections.length > 0) {\n        return;\n      } // As long as we have available connections\n      // eslint-disable-next-line\n\n\n      while (true) {\n        // Total availble connections\n        var totalConnections = self.availableConnections.length + self.connectingConnections.length + self.inUseConnections.length; // No available connections available, flush any monitoring ops\n\n        if (self.availableConnections.length === 0) {\n          // Flush any monitoring operations\n          flushMonitoringOperations(self.queue);\n          break;\n        } // No queue break\n\n\n        if (self.queue.length === 0) {\n          break;\n        } // Get a connection\n\n\n        var connection = null; // Locate all connections that have no work\n\n        var connections = []; // Get a list of all connections\n\n        for (var i = 0; i < self.availableConnections.length; i++) {\n          if (self.availableConnections[i].workItems.length === 0) {\n            connections.push(self.availableConnections[i]);\n          }\n        } // No connection found that has no work on it, just pick one for pipelining\n\n\n        if (connections.length === 0) {\n          connection = self.availableConnections[self.connectionIndex++ % self.availableConnections.length];\n        } else {\n          connection = connections[self.connectionIndex++ % connections.length];\n        } // Is the connection connected\n\n\n        if (connection.isConnected()) {\n          // Get the next work item\n          var workItem = self.queue.shift(); // If we are monitoring we need to use a connection that is not\n          // running another operation to avoid socket timeout changes\n          // affecting an existing operation\n\n          if (workItem.monitoring) {\n            var foundValidConnection = false;\n\n            for (i = 0; i < self.availableConnections.length; i++) {\n              // If the connection is connected\n              // And there are no pending workItems on it\n              // Then we can safely use it for monitoring.\n              if (self.availableConnections[i].isConnected() && self.availableConnections[i].workItems.length === 0) {\n                foundValidConnection = true;\n                connection = self.availableConnections[i];\n                break;\n              }\n            } // No safe connection found, attempt to grow the connections\n            // if possible and break from the loop\n\n\n            if (!foundValidConnection) {\n              // Put workItem back on the queue\n              self.queue.unshift(workItem); // Attempt to grow the pool if it's not yet maxsize\n\n              if (totalConnections < self.options.size && self.queue.length > 0) {\n                // Create a new connection\n                _createConnection(self);\n              } // Re-execute the operation\n\n\n              setTimeout(function () {\n                _execute(self)();\n              }, 10);\n              break;\n            }\n          } // Don't execute operation until we have a full pool\n\n\n          if (totalConnections < self.options.size) {\n            // Connection has work items, then put it back on the queue\n            // and create a new connection\n            if (connection.workItems.length > 0) {\n              // Lets put the workItem back on the list\n              self.queue.unshift(workItem); // Create a new connection\n\n              _createConnection(self); // Break from the loop\n\n\n              break;\n            }\n          } // Get actual binary commands\n\n\n          var buffer = workItem.buffer; // Set current status of authentication process\n\n          workItem.authenticating = self.authenticating;\n          workItem.authenticatingTimestamp = self.authenticatingTimestamp; // If we are monitoring take the connection of the availableConnections\n\n          if (workItem.monitoring) {\n            moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);\n          } // Track the executing commands on the mongo server\n          // as long as there is an expected response\n\n\n          if (!workItem.noResponse) {\n            connection.workItems.push(workItem);\n          } // We have a custom socketTimeout\n\n\n          if (!workItem.immediateRelease && typeof workItem.socketTimeout === 'number') {\n            connection.setSocketTimeout(workItem.socketTimeout);\n          } // Capture if write was successful\n\n\n          var writeSuccessful = true; // Put operation on the wire\n\n          if (Array.isArray(buffer)) {\n            for (i = 0; i < buffer.length; i++) {\n              writeSuccessful = connection.write(buffer[i]);\n            }\n          } else {\n            writeSuccessful = connection.write(buffer);\n          } // if the command is designated noResponse, call the callback immeditely\n\n\n          if (workItem.noResponse && typeof workItem.cb === 'function') {\n            workItem.cb(null, null);\n          }\n\n          if (writeSuccessful && workItem.immediateRelease && self.authenticating) {\n            removeConnection(self, connection);\n            self.nonAuthenticatedConnections.push(connection);\n          } else if (writeSuccessful === false) {\n            // If write not successful put back on queue\n            self.queue.unshift(workItem); // Remove the disconnected connection\n\n            removeConnection(self, connection); // Flush any monitoring operations in the queue, failing fast\n\n            flushMonitoringOperations(self.queue);\n          }\n        } else {\n          // Remove the disconnected connection\n          removeConnection(self, connection); // Flush any monitoring operations in the queue, failing fast\n\n          flushMonitoringOperations(self.queue);\n        }\n      }\n    });\n    self.executing = false;\n  };\n} // Make execution loop available for testing\n\n\nPool._execute = _execute;\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Pool#connect\n * @type {Pool}\n */\n\n/**\n * A server reconnect event, used to verify that pool reconnected.\n *\n * @event Pool#reconnect\n * @type {Pool}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Pool#close\n * @type {Pool}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Pool#error\n * @type {Pool}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Pool#timeout\n * @type {Pool}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Pool#parseError\n * @type {Pool}\n */\n\n/**\n * The driver attempted to reconnect\n *\n * @event Pool#attemptReconnect\n * @type {Pool}\n */\n\n/**\n * The driver exhausted all reconnect attempts\n *\n * @event Pool#reconnectFailed\n * @type {Pool}\n */\n\nmodule.exports = Pool;","map":null,"metadata":{},"sourceType":"script"}